window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "surfile", "modulename": "surfile", "kind": "module", "doc": "<p>Surfile</p>\n\n<hr />\n\n<p>Package for surface and profile processing</p>\n\n<p>Containers</p>\n\n<hr />\n\n<pre><code>- profile\n- surface\n</code></pre>\n\n<p>Example:\n    sur = surface.Surface()\n    sur.openFile(fname, interp=False, bplt=True)</p>\n\n<p>Utilities</p>\n\n<hr />\n\n<pre><code>- remover: levelling and form removal operations\n- filter: filtering of profile and surfaces\n- cutter: cutting edges and sections of topographies\n- extractor: profile extraction from surface\n</code></pre>\n\n<p>Example:\n    The utilities can be used in two ways:\n        - interactive: the program asks the user the parameters every time\n            extractor.ComplexExtractor.profile(sur, width=2, bplt=True)\n        - programmed: the user sets the parameters at the beginning\n            ex = extractor.ComplexExtractor()\n            ex.template()\n            ex.apply(sur, bplt=True)</p>\n\n<p>Processings</p>\n\n<hr />\n\n<pre><code>- roughness: PSD / roughness\n- morph: morphological features\n-slope: slope distribution analysis\n</code></pre>\n\n<p>GitHub: @andeledea, @...</p>\n"}, {"fullname": "surfile.cutter", "modulename": "surfile.cutter", "kind": "module", "doc": "<p>'surfile.cutter'</p>\n\n<ul>\n<li>Cutting operations for profiles and surfaces</li>\n</ul>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.cutter.Cutter", "modulename": "surfile.cutter", "qualname": "Cutter", "kind": "class", "doc": "<p>Class that provides methods for profile / surface cutting\nstatic methods are used to work directly on profiles / surfaces, cutter objects\ncan be instantiated to apply the same cut to multiple profiles / surfaces</p>\n", "bases": "abc.ABC"}, {"fullname": "surfile.cutter.Cutter.templateExtents", "modulename": "surfile.cutter", "qualname": "Cutter.templateExtents", "kind": "function", "doc": "<p>Asks the user to open a template profile / topography\nplots the template and asks where the user wants to cut.\nThe edges are saved and used everytime the cutter is\napplied to a profile / topography obj, see applyCut()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.Cutter.applyCut", "modulename": "surfile.cutter", "qualname": "Cutter.applyCut", "kind": "function", "doc": "<p>Applies the cut to the object passed using the extents\ndefined previously by the user, see templateExtents()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.ProfileCutter", "modulename": "surfile.cutter", "qualname": "ProfileCutter", "kind": "class", "doc": "<p>Class that provides methods for profile / surface cutting\nstatic methods are used to work directly on profiles / surfaces, cutter objects\ncan be instantiated to apply the same cut to multiple profiles / surfaces</p>\n", "bases": "Cutter, abc.ABC"}, {"fullname": "surfile.cutter.ProfileCutter.templateExtents", "modulename": "surfile.cutter", "qualname": "ProfileCutter.templateExtents", "kind": "function", "doc": "<p>Asks the user to open a template profile / topography\nplots the template and asks where the user wants to cut.\nThe edges are saved and used everytime the cutter is\napplied to a profile / topography obj, see applyCut()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.ProfileCutter.applyCut", "modulename": "surfile.cutter", "qualname": "ProfileCutter.applyCut", "kind": "function", "doc": "<p>Applies the cut to the object passed using the extents\ndefined previously by the user, see templateExtents()</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the cut is performed\nfinalize: bool\n    If False the cut is not finalized on the profile object\n    the method returns the cut vectors</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>cuts: tuple\n    tuple of cut arrays x and z respectively</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.ProfileCutter.cut", "modulename": "surfile.cutter", "qualname": "ProfileCutter.cut", "kind": "function", "doc": "<p>Cuts the profile at the margins defined manually by the user</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the cut is applied\nfinalize: bool\n    If set to False the cut will not alter the profile,\n    the method will only return the extents chosen by the user</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>extents: tuple\n    The cut span selected left and right x values\ncuts: list\n    The x and z arrays obtained after the cut</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.SurfaceCutter", "modulename": "surfile.cutter", "qualname": "SurfaceCutter", "kind": "class", "doc": "<p>Class that provides methods for profile / surface cutting\nstatic methods are used to work directly on profiles / surfaces, cutter objects\ncan be instantiated to apply the same cut to multiple profiles / surfaces</p>\n", "bases": "Cutter, abc.ABC"}, {"fullname": "surfile.cutter.SurfaceCutter.templateExtents", "modulename": "surfile.cutter", "qualname": "SurfaceCutter.templateExtents", "kind": "function", "doc": "<p>Asks the user to open a template profile / topography\nplots the template and asks where the user wants to cut.\nThe edges are saved and used everytime the cutter is\napplied to a profile / topography obj, see applyCut()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.SurfaceCutter.applyCut", "modulename": "surfile.cutter", "qualname": "SurfaceCutter.applyCut", "kind": "function", "doc": "<p>Applies the cut to the object passed using the extents\ndefined previously by the user, see templateExtents()</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the cut is performed\nfinalize: bool\n    If False the cut is not finalized on the profile object\n    the method returns the cut vectors</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>cuts: (np.array, np.array, np.array)\n    Tuple of cut arrays x y and z respectively</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.SurfaceCutter.cut", "modulename": "surfile.cutter", "qualname": "SurfaceCutter.cut", "kind": "function", "doc": "<p>Cuts the surface with a rectangle drawn by the user</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the cut is applied\nfinalize: bool\n    If set to False the cut will not alter the profile,\n    the method will only return the extents chosen by the user</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>extents (xmin, xmax, ymin, ymax):  (float, ...)\n    The cut borders\ncuts: list\n    The x, y, z, arrays obtained after the cut</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor", "modulename": "surfile.extractor", "kind": "module", "doc": "<p>'surfile.extractor'</p>\n\n<ul>\n<li>Creates a profile from a surface provides:\n<ul>\n<li>SimpleExtractor: profile parallel to x or y direction</li>\n<li>ComplexExtractor: profile can be any (even pieceWise defined)</li>\n<li>SphereExtractor: profile starting from the maximum point of the surface</li>\n</ul></li>\n</ul>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.extractor.Extractor", "modulename": "surfile.extractor", "qualname": "Extractor", "kind": "class", "doc": "<p>Class that provides methods for profile extraction from topographies\nstatic methods are used to work directly on surfaces, extractor objects\ncan be instantiated to apply the same extraction to multiple topographies</p>\n\n<p>The provided extraction can be divided into:</p>\n\n<ul>\n<li>simple extraction: the profile is parallel to x or y</li>\n<li>complex extraction: the profile can be any, even peacewise defined</li>\n<li>sphere extraction: the profile is along the x direction but starts from\nthe center of the spherical cup</li>\n</ul>\n", "bases": "abc.ABC"}, {"fullname": "surfile.extractor.Extractor.template", "modulename": "surfile.extractor", "qualname": "Extractor.template", "kind": "function", "doc": "<p>Asks the user to open a template topography\nplots the template and asks how to extract a profile.\nThe parameters are saved and used everytime the extractor is\napplied to a topography obj, see apply()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.Extractor.apply", "modulename": "surfile.extractor", "qualname": "Extractor.apply", "kind": "function", "doc": "<p>Applies the extraction to the object passed using the parameters\ndefined previously by the user, see template()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SimpleExtractor", "modulename": "surfile.extractor", "qualname": "SimpleExtractor", "kind": "class", "doc": "<p>Class that provides methods for profile extraction from topographies\nstatic methods are used to work directly on surfaces, extractor objects\ncan be instantiated to apply the same extraction to multiple topographies</p>\n\n<p>The provided extraction can be divided into:</p>\n\n<ul>\n<li>simple extraction: the profile is parallel to x or y</li>\n<li>complex extraction: the profile can be any, even peacewise defined</li>\n<li>sphere extraction: the profile is along the x direction but starts from\nthe center of the spherical cup</li>\n</ul>\n", "bases": "Extractor, abc.ABC"}, {"fullname": "surfile.extractor.SimpleExtractor.template", "modulename": "surfile.extractor", "qualname": "SimpleExtractor.template", "kind": "function", "doc": "<p>Asks the user to open a template topography\nplots the template and asks how to extract a profile.\nThe parameters are saved and used everytime the extractor is\napplied to a topography obj, see apply()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SimpleExtractor.apply", "modulename": "surfile.extractor", "qualname": "SimpleExtractor.apply", "kind": "function", "doc": "<p>Applies the extraction to the object passed using the parameters\ndefined previously by the user, see template()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SimpleExtractor.profile", "modulename": "surfile.extractor", "qualname": "SimpleExtractor.profile", "kind": "function", "doc": "<p>Extracts a profile along x or y at the position indicated by the user</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the profile is extracted\ndirection: str\n    The direction of the profile mean 'x' or 'y'\nwidth: int\n    The lateral number of values averged when extracting the profile\nbplt: bool\n    If True plots the extracted profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>profile: prf.Profile\n    Profile object exctracted from the topography\noptions: dict\n    The position selected by the user and the direction of extraction</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"o\">=</span><span class=\"s1\">&#39;x&#39;</span>, </span><span class=\"param\"><span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SimpleExtractor.meanProfile", "modulename": "surfile.extractor", "qualname": "SimpleExtractor.meanProfile", "kind": "function", "doc": "<p>Extracts the mean profile along x or y</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the profile is extracted\ndirection: str\n    The direction of the profile mean 'x' or 'y'\ncutter: cutter.Cutter\n    -if not set, the fit uses all points\n    -if true allows the user to select manually the region of interest\n    -if a cutter obj is passed the fit is done only on the cutted profile points\n     and then applied on the whole profile\nbplt: bool\n    If True plots the extracted profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>prf: profile.Profile\n    The mean profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"o\">=</span><span class=\"s1\">&#39;x&#39;</span>, </span><span class=\"param\"><span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.ComplexExtractor", "modulename": "surfile.extractor", "qualname": "ComplexExtractor", "kind": "class", "doc": "<p>Class that provides methods for profile extraction from topographies\nstatic methods are used to work directly on surfaces, extractor objects\ncan be instantiated to apply the same extraction to multiple topographies</p>\n\n<p>The provided extraction can be divided into:</p>\n\n<ul>\n<li>simple extraction: the profile is parallel to x or y</li>\n<li>complex extraction: the profile can be any, even peacewise defined</li>\n<li>sphere extraction: the profile is along the x direction but starts from\nthe center of the spherical cup</li>\n</ul>\n", "bases": "Extractor, abc.ABC"}, {"fullname": "surfile.extractor.ComplexExtractor.template", "modulename": "surfile.extractor", "qualname": "ComplexExtractor.template", "kind": "function", "doc": "<p>Asks the user to open a template topography\nplots the template and asks how to extract a profile.\nThe parameters are saved and used everytime the extractor is\napplied to a topography obj, see apply()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.ComplexExtractor.apply", "modulename": "surfile.extractor", "qualname": "ComplexExtractor.apply", "kind": "function", "doc": "<p>Applies the extraction to the object passed using the parameters\ndefined previously by the user, see template()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.ComplexExtractor.profile", "modulename": "surfile.extractor", "qualname": "ComplexExtractor.profile", "kind": "function", "doc": "<p>Opens a plot figure to choose the profile and extracts it\nThe profile is taken with a mpl.widgets.PolygonSelector</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the profile is extracted\nwidth: int\n    The lateral number of values averged when extracting the profile\nbplt: bool\n    If True plots the extracted profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>prf: profile.Profile\n    The extracted profile\npoints: the points selected by the user</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SphereExtractor", "modulename": "surfile.extractor", "qualname": "SphereExtractor", "kind": "class", "doc": "<p>Class that provides methods for profile extraction from topographies\nstatic methods are used to work directly on surfaces, extractor objects\ncan be instantiated to apply the same extraction to multiple topographies</p>\n\n<p>The provided extraction can be divided into:</p>\n\n<ul>\n<li>simple extraction: the profile is parallel to x or y</li>\n<li>complex extraction: the profile can be any, even peacewise defined</li>\n<li>sphere extraction: the profile is along the x direction but starts from\nthe center of the spherical cup</li>\n</ul>\n", "bases": "Extractor, abc.ABC"}, {"fullname": "surfile.extractor.SphereExtractor.sphereProfile", "modulename": "surfile.extractor", "qualname": "SphereExtractor.sphereProfile", "kind": "function", "doc": "<p>Returns the profile starting from the start point on the positive x direction</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the profile is extracted\nstartP : str\n    Method used to find the start (x, y) point on the topography\n        'max': the start point corresponds to the maximum Z of the topography\n        'fit': the start point is the center coords of the best fit sphere\n        'center': the start point is the center of the topography\n        'local': the start point is the local maximum closest to the center of the topography\nbplt: bool\n    If True plots the topography and the line where the profile is taken from</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>profile: prof.Profile()\n    The extracted profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">startP</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter", "modulename": "surfile.filter", "kind": "module", "doc": "<p>'surfile.filter'</p>\n\n<ul>\n<li>Applies a filter to a profile or a surface:\n<ul>\n<li>gaussian profile</li>\n<li>gaussian surface</li>\n<li>spline profile</li>\n<li>gaussian robust profile</li>\n</ul></li>\n</ul>\n\n<p>@author: Andrea Giura, Dorothee Hueser</p>\n"}, {"fullname": "surfile.filter.Filter", "modulename": "surfile.filter", "qualname": "Filter", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.filter.Filter.applyFilter", "modulename": "surfile.filter", "qualname": "Filter.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.Filter.plotEnvelope", "modulename": "surfile.filter", "qualname": "Filter.plotEnvelope", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Z</span>, </span><span class=\"param\"><span class=\"n\">envelope</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.Filter.plot3DEnvelope", "modulename": "surfile.filter", "qualname": "Filter.plot3DEnvelope", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"n\">Z</span>, </span><span class=\"param\"><span class=\"n\">envelope</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileGaussian", "modulename": "surfile.filter", "qualname": "ProfileGaussian", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.ProfileGaussian.__init__", "modulename": "surfile.filter", "qualname": "ProfileGaussian.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span></span>)</span>"}, {"fullname": "surfile.filter.ProfileGaussian.applyFilter", "modulename": "surfile.filter", "qualname": "ProfileGaussian.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileGaussian.filter", "modulename": "surfile.filter", "qualname": "ProfileGaussian.filter", "kind": "function", "doc": "<p>Applies to a profile object a gaussian filter ISO 16610-21.\nThe resulting profile is cut at the borders to avoid border effects.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the filter is applied\ncutoff: float\n    The cutoff of the gaussian filter\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileSpline", "modulename": "surfile.filter", "qualname": "ProfileSpline", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.ProfileSpline.__init__", "modulename": "surfile.filter", "qualname": "ProfileSpline.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">beta</span></span>)</span>"}, {"fullname": "surfile.filter.ProfileSpline.applyFilter", "modulename": "surfile.filter", "qualname": "ProfileSpline.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileSpline.filter", "modulename": "surfile.filter", "qualname": "ProfileSpline.filter", "kind": "function", "doc": "<p>Applies to a profile object a gaussian filter ISO 16610-22.\nThe resulting profile is cut at the borders to avoid border effects.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the filter is applied\ncutoff: float\n    The cutoff of the spline filter\nbeta: float\n    The tension parameter of the filter (0 &lt; beta &lt; 1)\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">beta</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileRobust", "modulename": "surfile.filter", "qualname": "ProfileRobust", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.ProfileRobust.__init__", "modulename": "surfile.filter", "qualname": "ProfileRobust.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span></span>)</span>"}, {"fullname": "surfile.filter.ProfileRobust.applyFilter", "modulename": "surfile.filter", "qualname": "ProfileRobust.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileRobust.filter_matrix", "modulename": "surfile.filter", "qualname": "ProfileRobust.filter_matrix", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileRobust.filter", "modulename": "surfile.filter", "qualname": "ProfileRobust.filter", "kind": "function", "doc": "<p>Applies to a profile object a gaussian robust filter ISO 16610-31.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the filter is applied\ncutoff: float\n    The cutoff of the gaussian filter\nbplt: bool\n    Plots the envelope of the filter if true\nThe use of this function requires the following citacion:\n    Seewig, Linear and robust Gaussian regression filters,\n    2005 J. Phys.: Conf. Ser. 13 254, doi:10.1088/1742-6596/13/1/059</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileMorph", "modulename": "surfile.filter", "qualname": "ProfileMorph", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.ProfileMorph.filter", "modulename": "surfile.filter", "qualname": "ProfileMorph.filter", "kind": "function", "doc": "<p>Apllies a morphological filter as described in ISO-21920,\nrolls a disk  of radius R (in mm) along the original profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the filter is applied\nradius: float\n    The radius of the sphere of the contact instrument\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.SurfaceGaussian", "modulename": "surfile.filter", "qualname": "SurfaceGaussian", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.SurfaceGaussian.__init__", "modulename": "surfile.filter", "qualname": "SurfaceGaussian.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span></span>)</span>"}, {"fullname": "surfile.filter.SurfaceGaussian.applyFilter", "modulename": "surfile.filter", "qualname": "SurfaceGaussian.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.SurfaceGaussian.filter", "modulename": "surfile.filter", "qualname": "SurfaceGaussian.filter", "kind": "function", "doc": "<p>Applies to a profile object a gaussian filter ISO 16610-21.\nThe resulting profile is cut at the borders to avoid border effects.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the filter is applied\ncutoff: float\n    The cutoff of the gaussian filter\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct", "modulename": "surfile.funct", "kind": "module", "doc": "<p>'surfile.funct'</p>\n\n<ul>\n<li>utility functions</li>\n<li>decorators for automation and code reusage</li>\n</ul>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.funct.Bcol", "modulename": "surfile.funct", "qualname": "Bcol", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.funct.persFig", "modulename": "surfile.funct", "qualname": "persFig", "kind": "function", "doc": "<p>Personalize an axis object or multiple</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>figures: list\n    The list of ax objects to be customized\ngridcol: str\n    The color of the grid\nxlab: str\nylab: str -> labels\nzlab: str</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">figures</span>, </span><span class=\"param\"><span class=\"n\">xlab</span>, </span><span class=\"param\"><span class=\"n\">ylab</span>, </span><span class=\"param\"><span class=\"n\">zlab</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">gridcol</span><span class=\"o\">=</span><span class=\"s1\">&#39;k&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.options", "modulename": "surfile.funct", "qualname": "options", "kind": "function", "doc": "<p>Decorator that implements global configurations</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>csvPath: str\n    If not none saves the return parameters of the decorated function to a csv\nsave: str\n    If not none saves the figures in the path\nbplt: bool\n    If True shows the images\nchrono: bool\n    If true times the duration of the decorated function</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Use this decorator only on methods that do not call plt.show</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csvPath</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">save</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">chrono</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.classOptions", "modulename": "surfile.funct", "qualname": "classOptions", "kind": "function", "doc": "<p>Class decorator uset to apply the same @dec to all methods</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">decorator</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.Rc", "modulename": "surfile.funct", "qualname": "Rc", "kind": "class", "doc": "<p>Class used to define the options of the decorators</p>\n\n<p>Parameters convention: each parameter has:</p>\n\n<ul>\n<li>1 letter indentifying the option\n<ul>\n<li>c: csv</li>\n<li>s: save the image</li>\n<li>b: bplt</li>\n<li>t: chrono</li>\n</ul></li>\n<li>1 letter identifying the type\n<ul>\n<li>s: surface</li>\n<li>p: profile</li>\n</ul></li>\n<li>3 chars identifying the decorated function</li>\n</ul>\n"}, {"fullname": "surfile.funct.Rc.load", "modulename": "surfile.funct", "qualname": "Rc.load", "kind": "function", "doc": "<p>Loads a user defined rc parameters file</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>js_fin: str\n    The json file name</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">js_fin</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.Rc.store", "modulename": "surfile.funct", "qualname": "Rc.store", "kind": "function", "doc": "<p>Saves the current parameters to a file</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>js_fout: str\n    The json file name</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">js_fout</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.Rc.setCurrentImage", "modulename": "surfile.funct", "qualname": "Rc.setCurrentImage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io", "modulename": "surfile.measfile_io", "kind": "module", "doc": "<p>'surfile.measfile_io'\nModule to read data output of microscopes:</p>\n\n<ul>\n<li>Olympus Lext</li>\n<li>Sensofar plu</li>\n<li>Asylum Cypher ibw</li>\n<li>Digital Surf sur</li>\n<li>SPIP bcr and bcrf</li>\n<li>ISO 25178-71 sdf</li>\n<li>NMM (Gaoliang)</li>\n</ul>\n\n<p>Created 2019-10-03\nlast edit 2021-04-02\n@author: Dorothee Hueser</p>\n"}, {"fullname": "surfile.measfile_io.str2float", "modulename": "surfile.measfile_io", "qualname": "str2float", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.extract_tag", "modulename": "surfile.measfile_io", "qualname": "extract_tag", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sdata</span>, </span><span class=\"param\"><span class=\"n\">tagkey</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_lextinfo", "modulename": "surfile.measfile_io", "qualname": "read_lextinfo", "kind": "function", "doc": "<p>read factor to convert raw data values into values in micron</p>\n\n<p>parameter:\nfilecontent: binary content of complete file</p>\n\n<p>return:\nnx, ny: number of data points/ pixel for each direction\nendheightmap: byte position of end of height map\nheightperpix: factor to be multiplied to raw data to obtain micron\nmagnification: of objective lens\nmeasdate: date an time when data where aquired with instrument</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filecontent</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_lextimg", "modulename": "surfile.measfile_io", "qualname": "read_lextimg", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">nx</span>, </span><span class=\"param\"><span class=\"n\">ny</span>, </span><span class=\"param\"><span class=\"n\">endheightmap</span>, </span><span class=\"param\"><span class=\"n\">heightflag</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_plu", "modulename": "surfile.measfile_io", "qualname": "read_plu", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filecontent</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_ibw", "modulename": "surfile.measfile_io", "qualname": "read_ibw", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_asciisdf", "modulename": "surfile.measfile_io", "qualname": "read_asciisdf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_sdf", "modulename": "surfile.measfile_io", "qualname": "read_sdf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_bcrf", "modulename": "surfile.measfile_io", "qualname": "read_bcrf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_sur", "modulename": "surfile.measfile_io", "qualname": "read_sur", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_NMMgaoliang", "modulename": "surfile.measfile_io", "qualname": "read_NMMgaoliang", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.identifybadborderlines", "modulename": "surfile.measfile_io", "qualname": "identifybadborderlines", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zval2d</span>, </span><span class=\"param\"><span class=\"n\">ny</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.interpol_csaps", "modulename": "surfile.measfile_io", "qualname": "interpol_csaps", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zmatrix</span>, </span><span class=\"param\"><span class=\"n\">wmatrix</span>, </span><span class=\"param\"><span class=\"n\">dx</span>, </span><span class=\"param\"><span class=\"n\">dy</span>, </span><span class=\"param\"><span class=\"n\">smoothparam</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.invalid_data_weight", "modulename": "surfile.measfile_io", "qualname": "invalid_data_weight", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">height_map</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_lextintensity", "modulename": "surfile.measfile_io", "qualname": "read_lextintensity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_microscopedata", "modulename": "surfile.measfile_io", "qualname": "read_microscopedata", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">userscalecorr</span>, </span><span class=\"param\"><span class=\"n\">interpolflag</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_HRTS", "modulename": "surfile.measfile_io", "qualname": "read_HRTS", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_pointcloud", "modulename": "surfile.measfile_io", "qualname": "read_pointcloud", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.lateral_axis", "modulename": "surfile.measfile_io", "qualname": "lateral_axis", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_lat</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.pointcloud_to_heightmap", "modulename": "surfile.measfile_io", "qualname": "pointcloud_to_heightmap", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dat_x</span>, </span><span class=\"param\"><span class=\"n\">dat_y</span>, </span><span class=\"param\"><span class=\"n\">dat_z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph", "modulename": "surfile.morph", "kind": "module", "doc": "<p>'surfile.morph'</p>\n\n<ul>\n<li>analysis of morphological features for:\n<ul>\n<li>Profiles</li>\n<li>Surfaces</li>\n</ul></li>\n</ul>\n\n<p>@author: Andrea Giura, Dorothee Hueser</p>\n"}, {"fullname": "surfile.morph.Roi", "modulename": "surfile.morph", "qualname": "Roi", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.morph.Roi.__init__", "modulename": "surfile.morph", "qualname": "Roi.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">Z</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span>)</span>"}, {"fullname": "surfile.morph.ProfileMorph", "modulename": "surfile.morph", "qualname": "ProfileMorph", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.morph.ProfileMorph.stepAuto", "modulename": "surfile.morph", "qualname": "ProfileMorph.stepAuto", "kind": "function", "doc": "<p>Calculates the step height using the auto method</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the steps are calculated\nbplt: bool\n    Plots the step reconstruction</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>steps: list\n    The calculated step heights\ndefinedPeaks: bool\n    False if the standard deviation of the flats is greater than step / 200\n    it gives an indication on how well the steps are defined</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph.ProfileMorph.histHeight", "modulename": "surfile.morph", "qualname": "ProfileMorph.histHeight", "kind": "function", "doc": "<p>Histogram method implementation</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the height is calculated\nbins: int\n    The number of bins of the histogram\nbplt: bool\n    Plots the histogram of the profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>height: float\n    The calculated height of the surface\n(hist, edges)\n    The histogram x and y</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph.ProfileMorph.arcSlope", "modulename": "surfile.morph", "qualname": "ProfileMorph.arcSlope", "kind": "function", "doc": "<p>Used to find the max measured slopes of arc of radius R</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the maximum meaasured slope is calculated\nR: float\n    The nominal radius of the arc</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>phi_max1: float\n    The slope calculated at breackpoint 1 (first nan value)\nphi_max2: float\n    The slope calculated at breackpoint 2 (last measured point)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph.ProfileMorph.arcRadius", "modulename": "surfile.morph", "qualname": "ProfileMorph.arcRadius", "kind": "function", "doc": "<p>Calculates the radius of the arc varying the z (top to bottom)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the radius is calculated\nskip: float\n    The first micrometers to skip\nbplt: bool\n    Plots the calculated radius at all the z values</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(r, z): (np.array(), ...)\n    The radius and the respective z values</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph.ProfileMorph.lateral", "modulename": "surfile.morph", "qualname": "ProfileMorph.lateral", "kind": "function", "doc": "<p>Evaluate RSM - N parameters with the sigmoid fit method\n@dorothee_hueser</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: The profile on which the steps are evaluated\nnom_pitch: the nominal pitch of the sample\nbplt: if true </p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>x_c: np.array\n    The center position of the features\nh_c: np.array\n    The calculated heights of the features</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph.SurfaceMorph", "modulename": "surfile.morph", "qualname": "SurfaceMorph", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.morph.SurfaceMorph.histHeight", "modulename": "surfile.morph", "qualname": "SurfaceMorph.histHeight", "kind": "function", "doc": "<p>Histogram method implementation</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the height is calculated\nbins: int\n    The number of bins of the histogram, if set to none the program will calculate\n    automatically the number of bins\nbplt: bool\n    Plots the histogram of the profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>height: float\n    The calculated height of the surface\n(hist, edges)\n    The histogram x and y</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph.SurfaceMorph.sphereSlope", "modulename": "surfile.morph", "qualname": "SurfaceMorph.sphereSlope", "kind": "function", "doc": "<p>Returns the maximum measurable slope in every direction</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the maximum slope is calculated\nR: float\n    The nominal radius of the sphere\nangleStep : int\n    The angle used to rotate the image after every iteration\nstart : str\n    Method used to find the start (x, y) point on the topography\n        'max': the start point is the maximum Z of the topography\n        'fit': the start point is the center of the best fit sphere\n        'center': the start point is the center of the topography\n        'local': the start point is the local maximum closest to the center of the topography\nbplt: bool\n    Plots the slope at the different angles</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>phi_max1 : np.array\nphi_max2 : np.array\n    The 2 slopes calculated at breackpoints 1 and 2 respectively</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph.SurfaceMorph.sphereRadius", "modulename": "surfile.morph", "qualname": "SurfaceMorph.sphereRadius", "kind": "function", "doc": "<p>Returns the radius of the profile in every direction</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the radius is calculated\nangleStepSize : int\n    The angle used to rotate the image after every iteration\nstart : str\n    Method used to find the start (x, y) point on the topography\n        'max': the start point is the maximum Z of the topography\n        'fit': the start point is the center of the best fit sphere\n        'center': the start point is the center of the topography\n        'local': the start point is the local maximum closest to the center of the topography\nbplt: bool\n    Plots the radius at the different angles</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(yr, yz): (np.array(), ...)\n    The mean of the radius and the mean of the different heights where the radius is calculated</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph.SurfaceMorph.cylinder", "modulename": "surfile.morph", "qualname": "SurfaceMorph.cylinder", "kind": "function", "doc": "<p>Evaluates radius and form deviation of a cylinder by fitting a least square cylinder\nto the points</p>\n\n<h2 id=\"parametersq\">Parametersq</h2>\n\n<p>obj: surface.Surface\n    The surface on which the processing is applied\nradius: float\n    The nominal radius of the cylinder\nphiCone: float\n    Angle in degree of the FOV of the instrument\nalphaZ: rotation of the cylinder axis about the Y axis (radian)\nconcavity: str\n    Can be either 'convex' or 'concave'\nbase: bool\n    If true removes the points at the base of the cylinder\nbplt: bool\n    Plots the sphere fitted to the data points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>R_all: float\n    The radius of the best fit cylinder to all points\nFD_all: float\n    The form deviation of the best fit cylinder to all points\nR_2s: float\n    The radius of the best fit cylinder to only the points with residue &lt; 2 * sigma\nFD_2s: float\n    The form deviation of the best fit cylinder to only the points with residue &lt; 2 * sigma</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.morph.SurfaceMorph.lateral", "modulename": "surfile.morph", "qualname": "SurfaceMorph.lateral", "kind": "function", "doc": "<p>Performs the 1D sigmoid analysis for each profile in the topography</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: The surface on which the analysis is carried out\nnom_pitch: The nominal pitch of the grating\ndirection: Orientation of the features (perpendicular to the steps)\nbplt: If true plots the </p>\n\n<h2 id=\"returns\">Returns</h2>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile", "modulename": "surfile.profile", "kind": "module", "doc": "<p>'surfile.profile'</p>\n\n<ul>\n<li>data structure for profile objects</li>\n<li>plots of the profile</li>\n<li>io operation for data storage</li>\n</ul>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.profile.Profile", "modulename": "surfile.profile", "qualname": "Profile", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.profile.Profile.openPrf", "modulename": "surfile.profile", "qualname": "Profile.openPrf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">bplt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.openTS", "modulename": "surfile.profile", "qualname": "Profile.openTS", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">bplt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.saveTxt", "modulename": "surfile.profile", "qualname": "Profile.saveTxt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.setValues", "modulename": "surfile.profile", "qualname": "Profile.setValues", "kind": "function", "doc": "<p>Sets the values for the profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X: []\n    The X values of the profile\nY: []\n    The Y values of the profile\nbplt: bool\n    Plots the profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"n\">bplt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.pltPrf", "modulename": "surfile.profile", "qualname": "Profile.pltPrf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.pltCompare", "modulename": "surfile.profile", "qualname": "Profile.pltCompare", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover", "modulename": "surfile.remover", "kind": "module", "doc": "<p>'surfile.remover'</p>\n\n<ul>\n<li>form removal operations, implements:\n<ul>\n<li>least square polynomial fits with bounded domain</li>\n<li>spherical fit</li>\n<li>cylinder fit</li>\n</ul></li>\n</ul>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.remover.polyval2d", "modulename": "surfile.remover", "qualname": "polyval2d", "kind": "function", "doc": "<p>Evaluate 2D polynomial coefficients\nONLY USED INTERNALLY FOR SURFACE RECONSTRUCTION</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : array_like of float\n    (shape1) x-coordinate independent interpolants\ny : array_like of float\n    (shape1) y-coordinate independent interpolants\ncoeffs : numpy.ndarray\n    (y_order + 1, x_order + 1) array of coefficients output by\n    <code>polyfit2d</code>.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>numpy.ndarray\n    (shape1) polynomial coefficients evaluated at (y,x).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">coeffs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.Remover", "modulename": "surfile.remover", "qualname": "Remover", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.remover.Remover.applyRemover", "modulename": "surfile.remover", "qualname": "Remover.applyRemover", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.Remover.plotForm", "modulename": "surfile.remover", "qualname": "Remover.plotForm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">coeff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.Remover.removeForm", "modulename": "surfile.remover", "qualname": "Remover.removeForm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">coeff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.Remover.plot3DForm", "modulename": "surfile.remover", "qualname": "Remover.plot3DForm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">coeff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.Remover.remove3DForm", "modulename": "surfile.remover", "qualname": "Remover.remove3DForm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">coeff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.ProfileLSLine", "modulename": "surfile.remover", "qualname": "ProfileLSLine", "kind": "class", "doc": "<p></p>\n", "bases": "Remover"}, {"fullname": "surfile.remover.ProfileLSLine.applyRemover", "modulename": "surfile.remover", "qualname": "ProfileLSLine.applyRemover", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.ProfileLSLine.remove", "modulename": "surfile.remover", "qualname": "ProfileLSLine.remove", "kind": "function", "doc": "<p>Least square line fit implementation</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the form is removed\nbplt: bool\n    If True plots the line overimposed on the profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(m, q): (float, ...)\n    The line equation coefficients</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.ProfilePolynomial", "modulename": "surfile.remover", "qualname": "ProfilePolynomial", "kind": "class", "doc": "<p></p>\n", "bases": "Remover"}, {"fullname": "surfile.remover.ProfilePolynomial.__init__", "modulename": "surfile.remover", "qualname": "ProfilePolynomial.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">degree</span>,</span><span class=\"param\">\t<span class=\"n\">comp</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">ProfilePolynomial</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "surfile.remover.ProfilePolynomial.applyRemover", "modulename": "surfile.remover", "qualname": "ProfilePolynomial.applyRemover", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.ProfilePolynomial.remove", "modulename": "surfile.remover", "qualname": "ProfilePolynomial.remove", "kind": "function", "doc": "<p>Plynomial fit implementation</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the form is removed\ncomp: funct / lambda\n    comparison method between bound and profile\ndegree: int\n    polynomial degree\nbound: float\n    -if not set the fit uses all points,\n    -if set the fit uses all points below the values,\n    -if set to True the fit uses only the values below the average value of the profile\ncutter: cutter.Cutter\n    -if not set, the fit uses all points\n    -if true allows the user to select manually the region of interest\n    -if a cutter obj is passed the fit is done only on the cutted profile points\n     and then applied on the whole profile\nbplt: bool\n    If True plots the polynomial form overimposed on the profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>coeff: np.array()\n    The polynomial form coefficients</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>,</span><span class=\"param\">\t<span class=\"n\">degree</span>,</span><span class=\"param\">\t<span class=\"n\">comp</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">ProfilePolynomial</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.ProfileHistogram", "modulename": "surfile.remover", "qualname": "ProfileHistogram", "kind": "class", "doc": "<p></p>\n", "bases": "Remover"}, {"fullname": "surfile.remover.ProfileHistogram.remove", "modulename": "surfile.remover", "qualname": "ProfileHistogram.remove", "kind": "function", "doc": "<p>Alligns the profile using the recursive histogram method, stops when\nthe tilt correction is less than the parameter final_m</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the form is removed\nfinal_m: float\n    The end slope correction\nbplt: bool\n    Plots the histogram evolution over the iterations</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">final_m</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.SurfaceLSPlane", "modulename": "surfile.remover", "qualname": "SurfaceLSPlane", "kind": "class", "doc": "<p></p>\n", "bases": "Remover"}, {"fullname": "surfile.remover.SurfaceLSPlane.applyRemover", "modulename": "surfile.remover", "qualname": "SurfaceLSPlane.applyRemover", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.SurfaceLSPlane.remove", "modulename": "surfile.remover", "qualname": "SurfaceLSPlane.remove", "kind": "function", "doc": "<p>Least square plane fit implementation</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the LS plane is applied\nbplt: bool\n    If True plots the plane overimposed on the surface</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sol: np.ndarray\n    Array of polynomial coefficients.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.SurfacePolynomial", "modulename": "surfile.remover", "qualname": "SurfacePolynomial", "kind": "class", "doc": "<p></p>\n", "bases": "Remover"}, {"fullname": "surfile.remover.SurfacePolynomial.__init__", "modulename": "surfile.remover", "qualname": "SurfacePolynomial.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kx</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">ky</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">full</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">comp</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">SurfacePolynomial</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "surfile.remover.SurfacePolynomial.applyRemover", "modulename": "surfile.remover", "qualname": "SurfacePolynomial.applyRemover", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.SurfacePolynomial.remove", "modulename": "surfile.remover", "qualname": "SurfacePolynomial.remove", "kind": "function", "doc": "<p>Least square polynomial fit implementation</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the polynomial fit is applied\nkx, ky: int\n    Polynomial order in x and y, respectively.\nfull : bool, optional\n    If True, will solve using the full polynomial matrix.  Otherwise,\n    will use the upper-left triangle of the matrix.  See\n    <code>polyinterp2d</code> for further details.  Note that if kx != ky, then\n    the full matrix will be solved for. (@sofia_redux/toolkit)\ncomp: funct / lambda, optional\n    comparison method between bound and surface\nbound: float, optional\n    if not set the fit uses all points,\n    if set the fit uses all points below the values,\n    if set to True the fit uses only the values below the average value of the surface\ncutter: cutter.Cutter\n    -if not set, the fit uses all points\n    -if true allows the user to select manually the region of interest\n    -if a cutter obj is passed the fit is done only on the cutted profile points\n     and then applied on the whole profile\nbplt: bool, optional\n    If True plots the plane overimposed on the surface</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sol: np.ndarray\n    Array of polynomial coefficients.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>,</span><span class=\"param\">\t<span class=\"n\">kx</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">ky</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">full</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">comp</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">SurfacePolynomial</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.Surface3Points", "modulename": "surfile.remover", "qualname": "Surface3Points", "kind": "class", "doc": "<p></p>\n", "bases": "Remover"}, {"fullname": "surfile.remover.Surface3Points.remove", "modulename": "surfile.remover", "qualname": "Surface3Points.remove", "kind": "function", "doc": "<p>3 points plane fit implementation\nOpens a plot figure to choose the 3 points and fids the plane for those points</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the polynomial fit is applied\nbplt: bool\n    If True plots the plane overimposed on the surface</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.Sphere", "modulename": "surfile.remover", "qualname": "Sphere", "kind": "class", "doc": "<p></p>\n", "bases": "Remover"}, {"fullname": "surfile.remover.Sphere.remove", "modulename": "surfile.remover", "qualname": "Sphere.remove", "kind": "function", "doc": "<p>Calculates the least square sphere</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the polynomial fit is applied\nfinalize: bool\n    If set to False the fit will not alter the surface,\n    the method will only return the center and the radius\nradius: float\n    If None the method will use the best fit radius\n    If a radius is passed then the program will use it\nbplt: bool\n    Plots the sphere fitted to the data points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(radius, C): (float, [xc, yc, zc])\n    Radius and sphere center coordinates</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.evalCyl", "modulename": "surfile.remover", "qualname": "evalCyl", "kind": "function", "doc": "<p>Evaluates the cylinder points given the 5 parameters</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the cylinder is calculated\nest_p: np.array\n    P[0] = r, radius of the cylinder\n    p[1] = Yc, y coordinate of the cylinder centre\n    P[2] = Zc, z coordinate of the cylinder centre\n    P[3] = alpha_z, rotation angle (radian) about the z-axis\n    P[4] = alpha_y, rotation angle (radian) about the y-axis\nconcavity:\n    Either 'concave' or 'convex'</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>z_cyl: np.ndarray\n    The calculated points\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">est_p</span>, </span><span class=\"param\"><span class=\"n\">concavity</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.remover.Cylinder", "modulename": "surfile.remover", "qualname": "Cylinder", "kind": "class", "doc": "<p></p>\n", "bases": "Remover"}, {"fullname": "surfile.remover.Cylinder.remove", "modulename": "surfile.remover", "qualname": "Cylinder.remove", "kind": "function", "doc": "<p>This is a fitting for a horizontal along x cylinder fitting\nuses the following parameters to find the best cylinder fit</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the cylinder fit is applied\nradius: float\n    The cylinder nominal radius\nalphaY:\n    An estimate ot the cylinder rotation about the y-axis (radian)\nalphaZ:\n    An estimate ot the cylinder rotation about the z-axis (radian)\nconcavity: str\n    Can be either 'convex' or 'concave'\nbase: bool\n    If true removes the points at the base of the cylinder\nfinalize: bool\n    If set to False the fit will not alter the surface,\n    the method will only return the center and the radius\nbplt: bool\n    Plots the sphere fitted to the data points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>est_p: np.array\n    P[0] = r, radius of the cylinder\n    p[1] = Yc, y coordinate of the cylinder centre\n    P[2] = Zc, z coordinate of the cylinder centre\n    P[3] = alpha_z, rotation angle (radian) about the z-axis\n    P[4] = alpha_y, rotation angle (radian) about the y-axis</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span>,</span><span class=\"param\">\t<span class=\"n\">alphaZ</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">alphaY</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">concavity</span><span class=\"o\">=</span><span class=\"s1\">&#39;convex&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">base</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.roughness", "modulename": "surfile.roughness", "kind": "module", "doc": "<p>'surfile.roughness'</p>\n\n<ul>\n<li>analysis of roughness features for:\n<ul>\n<li>Profiles</li>\n<li>Surfaces</li>\n</ul></li>\n</ul>\n\n<p>@author: Dorothee Hueser, Andrea Giura</p>\n"}, {"fullname": "surfile.roughness.eval_pinter", "modulename": "surfile.roughness", "qualname": "eval_pinter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">PSD</span>, </span><span class=\"param\"><span class=\"n\">fx0</span>, </span><span class=\"param\"><span class=\"n\">fy0</span>, </span><span class=\"param\"><span class=\"n\">frc</span>, </span><span class=\"param\"><span class=\"n\">theta</span>, </span><span class=\"param\"><span class=\"n\">nxDC</span>, </span><span class=\"param\"><span class=\"n\">nyDC</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.roughness.Psd", "modulename": "surfile.roughness", "qualname": "Psd", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.roughness.Psd.evalPsd", "modulename": "surfile.roughness", "qualname": "Psd.evalPsd", "kind": "function", "doc": "<p>Evaluate the power spectral density of the topography</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The topography\nbplt: bool\n    If True plots the PSD result</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>psd: np.ndarray\n    The calculated psd of the surface\nfx, fy: np.array\n    The x and y axis of the psd\npsd_x, psd_y: np.ndarray\n    The psd along the given axis</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.roughness.Psd.polarSpectra", "modulename": "surfile.roughness", "qualname": "Psd.polarSpectra", "kind": "function", "doc": "<p>Calculate the spectra in polar coordinates</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_fct: float\nbplt: bool\n    If true the spectra is plotted in a 3d projection axis</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>psdP: np.ndarray\n    The polar spectra evaluated\nFr, Th: np.array\n    The polar coordinate vectors</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df_fct</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.roughness.Psd.angleIntegratedSpectra", "modulename": "surfile.roughness", "qualname": "Psd.angleIntegratedSpectra", "kind": "function", "doc": "<p>Calculate the angle integrated</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_fct: float\nbplt: bool\n    If true the angle integrated spectra is plotted</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>psdP: np.ndarray\n    The polar spectra evaluated\nFr, Th: np.array\n    The polar coordinate vectors</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df_fct</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.roughness.Psd.averageSpectra", "modulename": "surfile.roughness", "qualname": "Psd.averageSpectra", "kind": "function", "doc": "<p>Calculate the average specra in the x and y directions</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>bplt: bool\n    Plots the mean spectra if true</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>psdMeanx, psdMeany: np.array\n    The mean psd arrays</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.roughness.Roi", "modulename": "surfile.roughness", "qualname": "Roi", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.roughness.Roi.__init__", "modulename": "surfile.roughness", "qualname": "Roi.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>, </span><span class=\"param\"><span class=\"n\">Z</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "surfile.roughness.Parameters", "modulename": "surfile.roughness", "qualname": "Parameters", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.roughness.Parameters.calc", "modulename": "surfile.roughness", "qualname": "Parameters.calc", "kind": "function", "doc": "<p>Calculates the roughness parameters of a profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile on which the parameters are calculates\nrem: remover.Remover\n    - if None, the low frequency components are not filtered\nfil: filter.Filter\n    The filter that is applied before the calculations. The cutoff\n    of the filter is used to select the central region of the profile,\n    half cutof is not condsidered at the adges of the rofile\nbplt: bool\n    If true plots the profile after the pre-proocessing</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RA, RQ, RP, RV, RZ, RSK, RKU: (float, ...)\n    Calculated roughness parameters</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>,</span><span class=\"param\">\t<span class=\"n\">rem</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">remover</span><span class=\"o\">.</span><span class=\"n\">Remover</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fil</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"o\">.</span><span class=\"n\">Filter</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.slope", "modulename": "surfile.slope", "kind": "module", "doc": "<p>'surfile.slope'</p>\n\n<ul>\n<li>analysis of slope distribution for:\n<ul>\n<li>Surfaces</li>\n</ul></li>\n</ul>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.slope.slopeDistribution", "modulename": "surfile.slope", "qualname": "slopeDistribution", "kind": "function", "doc": "<p>Calculates the slope distribution in angles theta and phi</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface n wich the slope distribution is calculated\nstructured: bool\n    If true the method assumes equal spacing along x-axis (dx) and equal spacing along\n    y-axis\n    If false the method uses a generalized triangle approach (recommended)\ntheta_bins: int\n    The number of bins for the Theta distribution\nphi_bins: int\n    The number of bins for the Phi distribution\nbplt: bool\n    If True plots the calculated histograms</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(hist_theta, edges_theta): tuple\n    The theta histogram\n(hist_phi, edges_phi): tuple\n    The phi histogram</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>,</span><span class=\"param\">\t<span class=\"n\">structured</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">theta_bins</span><span class=\"o\">=</span><span class=\"mi\">90</span>,</span><span class=\"param\">\t<span class=\"n\">phi_bins</span><span class=\"o\">=</span><span class=\"mi\">360</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface", "modulename": "surfile.surface", "kind": "module", "doc": "<p>'surfile.surface'</p>\n\n<ul>\n<li>data structure for surface objects</li>\n<li>plots of the surface</li>\n<li>basic transformation methods (resample, rotation)</li>\n<li>io operation for data storage</li>\n</ul>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.surface.Surface", "modulename": "surfile.surface", "qualname": "Surface", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.surface.Surface.openTxt", "modulename": "surfile.surface", "qualname": "Surface.openTxt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">bplt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.openFile", "modulename": "surfile.surface", "qualname": "Surface.openFile", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">bplt</span>, </span><span class=\"param\"><span class=\"n\">interp</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.saveAsc", "modulename": "surfile.surface", "qualname": "Surface.saveAsc", "kind": "function", "doc": "<p>Saves the topography in the .asc file format</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname: str\n    If fname is a folder the file will be saved in that folder with the surface name\n    If fname is not a folder the file will be saved at fname</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.saveTxt", "modulename": "surfile.surface", "qualname": "Surface.saveTxt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.rotate", "modulename": "surfile.surface", "qualname": "Surface.rotate", "kind": "function", "doc": "<p>Rotates the original topography by the specified angle</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>angle: float\n    The angle of rotation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">angle</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.resample", "modulename": "surfile.surface", "qualname": "Surface.resample", "kind": "function", "doc": "<p>Resamples the topography and fills the non-measured points</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>newXsize: int\n    Number of points desired on the x-axis\nnewYsize: int\n    Number of points desired on the y-axis</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newXsize</span>, </span><span class=\"param\"><span class=\"n\">newYsize</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.fillNM", "modulename": "surfile.surface", "qualname": "Surface.fillNM", "kind": "function", "doc": "<p>Fills the surface non measured points</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.toProfiles", "modulename": "surfile.surface", "qualname": "Surface.toProfiles", "kind": "function", "doc": "<p>Splits the topography into vertical or horizontal profiles</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>axis: str\n    'x' or 'y', the axis on which the f is applied</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>res: []\n    The resulting profiles</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;x&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.plt3D", "modulename": "surfile.surface", "qualname": "Surface.plt3D", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.pltCompare", "modulename": "surfile.surface", "qualname": "Surface.pltCompare", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.pltC", "modulename": "surfile.surface", "qualname": "Surface.pltC", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();