window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "surfile", "modulename": "surfile", "kind": "module", "doc": "<hr />\n\n<p>Package for surface and profile processing</p>\n\n<h6 id=\"containers\">Containers</h6>\n\n<ul>\n<li>profile</li>\n<li>surface</li>\n</ul>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sur</span> <span class=\"o\">=</span> <span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sur</span><span class=\"o\">.</span><span class=\"n\">openFile</span><span class=\"p\">(</span><span class=\"n\">fname</span><span class=\"p\">,</span> <span class=\"n\">interp</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<h6 id=\"utilities\">Utilities</h6>\n\n<ul>\n<li>stitcher: stitching of topography for augmented FOV</li>\n<li>cutter: cutting edges and sections of topographies</li>\n<li>extractor: profile extraction from surface</li>\n</ul>\n\n<p>The utilities can be used in two ways:</p>\n\n<ul>\n<li><p>interactive: the program asks the user the parameters every time</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">extractor</span><span class=\"o\">.</span><span class=\"n\">ComplexExtractor</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"p\">(</span><span class=\"n\">sur</span><span class=\"p\">,</span> <span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div></li>\n<li><p>programmed: the user sets the parameters at the beginning</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ex</span> <span class=\"o\">=</span> <span class=\"n\">extractor</span><span class=\"o\">.</span><span class=\"n\">ComplexExtractor</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">template</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"n\">apply</span><span class=\"p\">(</span><span class=\"n\">sur</span><span class=\"p\">,</span> <span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div></li>\n</ul>\n\n<h6 id=\"processings\">Processings</h6>\n\n<ul>\n<li>texture: PSD / roughness / slopeDistribution</li>\n<li>filter: filtering of profile and surfaces (alpha state)</li>\n<li>analysis: gratings, readius calculation</li>\n</ul>\n\n<h6 id=\"structure\">Structure</h6>\n\n<pre class=\"mermaid-pre\"><div class=\"mermaid\">graph RL;\n    A[surfile.analysis]--&gt; C &amp; D &amp; E[surfile.profile] &amp; G;\n    B[surfile.cutter]--&gt; D &amp; E &amp; G;\n    C[surfile.extractor]--&gt; B &amp; D &amp; E &amp; G;\n    D[surfile.geometry]--&gt; B &amp; E &amp; G;\n    M[surfile.stitcher]--&gt; G;\n    G[surfile.surface]--&gt; E;\n    H[surfile.texture]--&gt; D &amp; E &amp; G;\n</div></pre>\n\n<h6 id=\"dependencies\">Dependencies</h6>\n\n<p>This package depends on the following packages\nmatplotlib</p>\n\n<ul>\n<li>scipy</li>\n<li>numpy</li>\n<li>circle_fit</li>\n<li>open3d</li>\n<li>csaps (optional)</li>\n<li>igor (optional)</li>\n<li>alive_pogress</li>\n</ul>\n\n<p>To install all packages run:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pip</span> <span class=\"n\">install</span> <span class=\"n\">matplotlib</span> <span class=\"n\">circle_fit</span> <span class=\"n\">alive_progress</span> <span class=\"n\">open3d</span> <span class=\"n\">csaps</span> <span class=\"n\">igor</span>\n</code></pre>\n</div>\n\n<p>To view documentation interactively run:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">pip</span> <span class=\"n\">install</span> <span class=\"n\">pdoc</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">python3</span> <span class=\"o\">-</span><span class=\"n\">m</span> <span class=\"n\">pdoc</span> <span class=\"n\">surfile</span> <span class=\"o\">--</span><span class=\"n\">math</span> <span class=\"o\">--</span><span class=\"n\">mermaid</span>\n<span class=\"go\">and open the localhost server in the browser.</span>\n</code></pre>\n</div>\n\n<p>GitHub: @andeledea, @...</p>\n"}, {"fullname": "surfile.analysis", "modulename": "surfile.analysis", "kind": "module", "doc": "<p>'surfile.analysis'</p>\n\n<ul>\n<li>analysis for:\n<ul>\n<li>Profiles</li>\n<li>Surfaces</li>\n</ul></li>\n</ul>\n\n<p>@author: Andrea Giura, Dorothee Hueser</p>\n"}, {"fullname": "surfile.analysis.Roi", "modulename": "surfile.analysis", "qualname": "Roi", "kind": "class", "doc": "<p>Simple class to handle profile sections</p>\n"}, {"fullname": "surfile.analysis.Roi.__init__", "modulename": "surfile.analysis", "qualname": "Roi.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">Z</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span>)</span>"}, {"fullname": "surfile.analysis.Roi.X", "modulename": "surfile.analysis", "qualname": "Roi.X", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list"}, {"fullname": "surfile.analysis.Roi.Z", "modulename": "surfile.analysis", "qualname": "Roi.Z", "kind": "variable", "doc": "<p></p>\n", "annotation": ": list"}, {"fullname": "surfile.analysis.ProfileAnalysis", "modulename": "surfile.analysis", "qualname": "ProfileAnalysis", "kind": "class", "doc": "<p>Class that contains all the methods relative to Profile\nanalysis</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>All the methods in this class are implemented as a @staticmethod\nso this class is only used as a namespace to include all the routines\nrelative to profile analysis.</p>\n\n<p>Many of the methods of this function are called from functions \nof the SurfaceAnalysis class, but they can be called also to process\nsingle profile objects.</p>\n"}, {"fullname": "surfile.analysis.ProfileAnalysis.stepAuto", "modulename": "surfile.analysis", "qualname": "ProfileAnalysis.stepAuto", "kind": "function", "doc": "<p>Calculates the step height by finding the position of\nthe walls automatically.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the steps are calculated\nbplt: bool\n    Plots the step reconstruction</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>steps: list\n    The calculated step heights\ndefinedPeaks: bool\n    False if the standard deviation of the flats is greater than step / 200\n    it gives an indication on how well the steps are defined</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>To automate the selection of the areas @ the left, right and center of the step,\nwhich will henceforth be called regions of interest (ROIs), the programme calculates \nthe first derivative of the profile p'(x) and a threshold value that will be used \nto search peaks above its value. Once the peaks have been defined, it is possible to \nderive the ROIs as segments in between the peaks and one third the width of the distance \nbetween the two peaks that include it.</p>\n\n<p>$h_{step}=\\overline{ROI_{middle}}-\\frac{\\overline{ROI_{left}}+\\overline{ROI_{right}}}{2}$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.ProfileAnalysis.histHeight", "modulename": "surfile.analysis", "qualname": "ProfileAnalysis.histHeight", "kind": "function", "doc": "<p>Calculates the height of the sample using the histogram \nmethod.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the height is calculated\nbins: int\n    The number of bins of the histogram\nbplt: bool\n    Plots the histogram of the profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>height: float\n    The calculated height of the surface\n(hist, edges)\n    The histogram x and y</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The histogram of the Z values of the object describes how many pixels \nare present in the image at a certain height. In the case of a step\nheight sample the histogram presents two peaks, the program calculates\nthe difference between the two peaks and returns the height.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.ProfileAnalysis.arcSlope", "modulename": "surfile.analysis", "qualname": "ProfileAnalysis.arcSlope", "kind": "function", "doc": "<p>Finds the max measured slopes of arc of radius R at two breakpoints</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the maximum meaasured slope is calculated\nR: float\n    The nominal radius of the arc</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>phi_max1: float\n    The slope calculated at breackpoint 1 (first nan value)\nphi_max2: float\n    The slope calculated at breackpoint 2 (last measured point)</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The first breakpoint $b_1$ is taken at the first non-measured point, \nthe second breakpoint $b_2$ is taken at the last measured point.</p>\n\n<p>$\\Phi_{MS1}=asin(\\frac{b_1}{R})$\n$\\Phi_{MS2}=asin(\\frac{b_2}{R})$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.ProfileAnalysis.arcRadius", "modulename": "surfile.analysis", "qualname": "ProfileAnalysis.arcRadius", "kind": "function", "doc": "<p>Calculates the radius of the arc varying the z (top to bottom)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the radius is calculated\nskip: float\n    The first micrometers to skip\nbplt: bool\n    Plots the calculated radius at all the z values</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(r, z): (np.array(), ...)\n    The radius and the respective z values</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The radius of the arc for a specific height is then calculated as:\n$ R_i=\\frac{x_i^2+z_{eh,i}^2}{2z_{eh,i}}$\nwhere $x_i^2$ is the $x$ coordinate of the $i_{th}$ point, $z_{(eh,i)}$ \nis the distance between the maximum value of the profile and the $z$ \ncoordinate of point $i$; $R_i$ represent the radius calculated at point $i$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.ProfileAnalysis.grating_1d", "modulename": "surfile.analysis", "qualname": "ProfileAnalysis.grating_1d", "kind": "function", "doc": "<p>Determines height and pitch of 1D gratings\nof line bars of rectangular cross-section, where the trench width\nis equal to the bar width.\nThe bar cross-sections are modelled as rectangular boxes with\nsmoothed corners using a combination of sigmoidal functions.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile on which the steps are evaluated\nnom_pitch: float\n    the nominal pitch of the sample\nbplt: Bool\n    if true plots the sine and the sigmoid fit</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>x_c: np.array\n    The center position of the features\nh_c: np.array\n    The calculated heights of the features</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>At first the extracted profile is fitted with a least square sine wave,\nthis is used to find the centres of the features.</p>\n\n<p>$\\min_b {\\sum_{i=0}^{n_1}(z_i-\\frac{1}{2}b_0cos(\\frac{\\pi}{b_2}(x_i-b_1))-b_3-b_4x_i)^2}$</p>\n\n<p>The sigmoidal funtion fit is in the form:</p>\n\n<p>$f_s(x_{SW})=\\frac{1}{1+e^{\\frac{s(p_1-x)-x_{SW}}{p_4}}}$</p>\n\n<p>$z_M(\\mathbf{p},x)=p_0(f_{+1}(\\frac{1}{2}p_2)f_{-1}(\\frac{1}{2}p_2)-f_{+1}\n(\\frac{3}{2}p_2)f_{-1}(\\frac{3}{2}p_2))$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.SurfaceAnalysis", "modulename": "surfile.analysis", "qualname": "SurfaceAnalysis", "kind": "class", "doc": "<p>Class that contains all the methods relative to Surface\nanalysis</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>All the methods in this class are implemented as a @staticmethod\nso this class is only used as a namespace to include all the routines\nrelative to surface analysis.</p>\n"}, {"fullname": "surfile.analysis.SurfaceAnalysis.histHeight", "modulename": "surfile.analysis", "qualname": "SurfaceAnalysis.histHeight", "kind": "function", "doc": "<p>Calculates the height of the sample using the histogram \nmethod.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The profile object on wich the height is calculated\nbins: int\n    The number of bins of the histogram\nbplt: bool\n    Plots the histogram of the profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>height: float\n    The calculated height of the surface\n(hist, edges)\n    The histogram x and y</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The histogram of the Z values of the object describes how many pixels \nare present in the image at a certain height. In the case of a step\nheight sample the histogram presents two peaks, the program calculates\nthe difference between the two peaks and returns the height.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.SurfaceAnalysis.maxMeasSlope", "modulename": "surfile.analysis", "qualname": "SurfaceAnalysis.maxMeasSlope", "kind": "function", "doc": "<p>Calculates the maximum measurable slope in the radial directions\ngiven a topography of a sphere measured with the instrument.\nSee ProfileAnalysis.arcSlope() for details.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the maximum slope is calculated\nR : float\n    The nominal radius of the sphere\nangleStep : int\n    The angle used to rotate the image after every iteration\nstart : str\n    Method used to find the start (x, y) point on the topography\n        'max': the start point is the maximum Z of the topography\n        'fit': the start point is the center of the best fit sphere\n        'center': the start point is the center of the topography\n        'local': the start point is the local maximum closest to the center of the topography\nbplt : bool\n    Plots the slope at the different angles (linear and radial plots)</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>phi_max1 : np.array\nphi_max2 : np.array\n    The 2 slopes calculated at breackpoints 1 and 2 respectively</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.SurfaceAnalysis.sphereRadius", "modulename": "surfile.analysis", "qualname": "SurfaceAnalysis.sphereRadius", "kind": "function", "doc": "<p>Returns the radius of the sphere in the radial direction\nand at each height. Calculates and plots the average value of\nthe radius at each height.\nSee ProfileAnalysis.arcRadius() for details.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the radius is calculated\nangleStepSize : int\n    The angle used to rotate the image after every iteration\nstart : str\n    Method used to find the start (x, y) point on the topography\n        'max': the start point is the maximum Z of the topography\n        'fit': the start point is the center of the best fit sphere\n        'center': the start point is the center of the topography\n        'local': the start point is the local maximum closest to the center of the topography\nbplt: bool\n    Plots the radius at the different angles</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(yr, yz): (np.array(), ...)\n    The mean of the radius and the mean of the different heights where the radius is calculated</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.SurfaceAnalysis.cylinder", "modulename": "surfile.analysis", "qualname": "SurfaceAnalysis.cylinder", "kind": "function", "doc": "<p>Evaluates radius and form deviation of a cylinder by fitting a least square cylinder\nto the points and applying cuts to the surface to avoid edge points.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface on which the processing is applied\nradius : float\n    The nominal radius of the cylinder\nphiCone : float\n    Angle in degree of the FOV of the instrument\nalphaZ : float\n    Rotation of the cylinder axis about the Y axis (radian)\nconcavity : str\n    Can be either 'convex' or 'concave'\nbase : bool\n    If true removes the points at the base of the cylinder\nbplt : bool\n    Plots the sphere fitted to the data points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>R_all : float\n    The radius of the best fit cylinder to all points\nFD_all : float\n    The form deviation of the best fit cylinder to all points\nR_2s : float\n    The radius of the best fit cylinder to only the points with residue &lt; 2 * sigma\nFD_2s : float\n    The form deviation of the best fit cylinder to only the points with residue &lt; 2 * sigma</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>At first, the points of the cylinder measured by the optical profilometer are fitted with the \nleast squares algorithm Surfile.geometry.cylinder(); this fit is used to calculate the equation \nof the cylinder and the residuals of the measured points compared to the calculated points.\nBased on the results obtained, the measured points are eliminated where the following inequality \nis satisfied, in order to cut out any outlier point far from the cylinder axis:</p>\n\n<p>$|y-(\\frac{m}{l})x-y_0|&gt;\\frac{2Rsin \\cdot (\\phi)}{cos(\\alpha_z)}$\nwhere $m$ and $l$ are the components of the versor that represent the cylinder axis direction,\nR is the estimated radius of the circular base of the cylinder, $\\alpha_z$ is the rotation of the \ncylinder axis around the Z-axis, $\\phi$ is the cone angle of the objective specified by the instrument\nmanufacturer, $y_0$  the intercept of the axis.\nA second cylinder fit is then applied to all remaining points and $R_{all}$ and $FD_{all}$ parameters are \ncalculated, a third cylinder fit is done on the points that in the initial fit had a radial residue \nbelow $2\\sigma$ and $R_{2\\sigma}$ and $FD_{2\\sigma}$ can be finally calculated.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.SurfaceAnalysis.grating_1d", "modulename": "surfile.analysis", "qualname": "SurfaceAnalysis.grating_1d", "kind": "function", "doc": "<p>Determines height and pitch of 1D gratings\nof line bars of rectangular cross-section, where the trench width\nis equal to the bar width.\nThe bar cross-sections are modelled as rectangular boxes with\nsmoothed corners using a combination of sigmoidal functions.\nSee ProfileAnalysis.grating_1d() for details on the sigmoidal fit.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The \"surface\" on which the analysis is carried out\nnom_pitch: float\n    The nominal pitch of the grating\ndirection: str\n    Orientation of the features (perpendicular to the grating bars)\nbplt: bool\n    If true plots the calculated heights and regression lines</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>hs: float\n    Calculated mean height\npitch: float\n    Calculated mean pitch\ns_pitch: float\n    standard error of the pitch</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.TipCorrection", "modulename": "surfile.analysis", "qualname": "TipCorrection", "kind": "class", "doc": "<p>Class for tip correction utilities</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p><span style=\"color:orange\">This class will be moved to a utility module in the future\nuse with caution !!!</span>.</p>\n"}, {"fullname": "surfile.analysis.TipCorrection.erosion", "modulename": "surfile.analysis", "qualname": "TipCorrection.erosion", "kind": "function", "doc": "<p>Tip correction method implementation,\nrolls a disk  of radius R (in mm) along the original profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the filter is applied\nradius: float\n    The radius of the sphere of the contact instrument\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.analysis.TipCorrection.naive", "modulename": "surfile.analysis", "qualname": "TipCorrection.naive", "kind": "function", "doc": "<p>Tip correction implementation,\nrolls a disk  of radius R (in mm) along the original profile\nUses the naive approach described in:\n\"Algorithms for morph profile filters and their comparison\"\nShan Lou, Xiangqian Jiang, Paul J. Scott. (2012)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the filter is applied\nradius: float\n    The radius of the sphere of the contact instrument\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter", "modulename": "surfile.cutter", "kind": "module", "doc": "<p>'surfile.cutter'</p>\n\n<ul>\n<li>Cutting operations for profiles and surfaces</li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>These utilities are implemented as classes in order to allow the creation \nof templates to apply the same processing to multiple images.\nThe class implementation also allows the creation of cutter and selector \nobjects in other methods such as levelling or feature extraction routines.</p>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.cutter.Cutter", "modulename": "surfile.cutter", "qualname": "Cutter", "kind": "class", "doc": "<p>Class that provides methods for profile / surface cutting\nstatic methods are used to work directly on profiles / surfaces, cutter objects\ncan be instantiated to apply the same cut to multiple profiles / surfaces</p>\n", "bases": "abc.ABC"}, {"fullname": "surfile.cutter.Cutter.extents", "modulename": "surfile.cutter", "qualname": "Cutter.extents", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.cutter.Cutter.templateExtents", "modulename": "surfile.cutter", "qualname": "Cutter.templateExtents", "kind": "function", "doc": "<p>Asks the user to open a template profile / topography\nplots the template and asks where the user wants to cut.\nThe edges are saved and used everytime the cutter is\napplied to a profile / topography obj, see applyCut()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.Cutter.applyCut", "modulename": "surfile.cutter", "qualname": "Cutter.applyCut", "kind": "function", "doc": "<p>Applies the cut to the object passed using the extents\ndefined previously by the user, see templateExtents()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.ProfileCutter", "modulename": "surfile.cutter", "qualname": "ProfileCutter", "kind": "class", "doc": "<p>Class that provides methods for profile / surface cutting\nstatic methods are used to work directly on profiles / surfaces, cutter objects\ncan be instantiated to apply the same cut to multiple profiles / surfaces</p>\n", "bases": "Cutter, abc.ABC"}, {"fullname": "surfile.cutter.ProfileCutter.templateExtents", "modulename": "surfile.cutter", "qualname": "ProfileCutter.templateExtents", "kind": "function", "doc": "<p>Asks the user to open a template profile / topography\nplots the template and asks where the user wants to cut.\nThe edges are saved and used everytime the cutter is\napplied to a profile / topography obj, see applyCut()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.ProfileCutter.applyCut", "modulename": "surfile.cutter", "qualname": "ProfileCutter.applyCut", "kind": "function", "doc": "<p>Applies the cut to the object passed using the extents\ndefined previously by the user, see templateExtents()</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the cut is performed\nfinalize: bool\n    If False the cut is not finalized on the profile object\n    the method returns the cut vectors</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>cuts: tuple\n    tuple of cut arrays x and z respectively</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.ProfileCutter.cut", "modulename": "surfile.cutter", "qualname": "ProfileCutter.cut", "kind": "function", "doc": "<p>Cuts the profile at the margins defined manually by the user</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the cut is applied\nfinalize: bool\n    If set to False the cut will not alter the profile,\n    the method will only return the extents chosen by the user</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>extents: tuple\n    The cut span selected left and right x values\ncuts: list\n    The x and z arrays obtained after the cut</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.ProfileCutter.circleCut", "modulename": "surfile.cutter", "qualname": "ProfileCutter.circleCut", "kind": "function", "doc": "<p>Function to divide a circle profile starting from the\nmaximum value to the 2 edges of the profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile to be divided in two parts\nstartP : str\n    The method used to find the maximum point\n    - 'max': uses the maximum value of the profile\n    - 'fit': uses the center coordinate calculated with a LS fit</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>prfl : profile.Profile\nprfr : profile.Profile\n    The two extracted profiles</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>Exception\n    If the startP parameter is not correct</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">startP</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.SurfaceCutter", "modulename": "surfile.cutter", "qualname": "SurfaceCutter", "kind": "class", "doc": "<p>Class that provides methods for profile / surface cutting\nstatic methods are used to work directly on profiles / surfaces, cutter objects\ncan be instantiated to apply the same cut to multiple profiles / surfaces</p>\n", "bases": "Cutter, abc.ABC"}, {"fullname": "surfile.cutter.SurfaceCutter.templateExtents", "modulename": "surfile.cutter", "qualname": "SurfaceCutter.templateExtents", "kind": "function", "doc": "<p>Asks the user to open a template profile / topography\nplots the template and asks where the user wants to cut.\nThe edges are saved and used everytime the cutter is\napplied to a profile / topography obj, see applyCut()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.SurfaceCutter.applyCut", "modulename": "surfile.cutter", "qualname": "SurfaceCutter.applyCut", "kind": "function", "doc": "<p>Applies the cut to the object passed using the extents\ndefined previously by the user, see templateExtents()</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the cut is performed\nfinalize: bool\n    If False the cut is not finalized on the profile object\n    the method returns the cut vectors</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>cuts: (np.array, np.array, np.array)\n    Tuple of cut arrays x y and z respectively</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.SurfaceCutter.cut", "modulename": "surfile.cutter", "qualname": "SurfaceCutter.cut", "kind": "function", "doc": "<p>Cuts the surface with a rectangle drawn by the user</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the cut is applied\nfinalize: bool\n    If set to False the cut will not alter the profile,\n    the method will only return the extents chosen by the user</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>extents (xmin, xmax, ymin, ymax):  (float, ...)\n    The cut borders\ncuts: list\n    The x, y, z, arrays obtained after the cut</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.cutter.HistCutter", "modulename": "surfile.cutter", "qualname": "HistCutter", "kind": "class", "doc": "<p>Class that provides methods for profile / surface cutting\nstatic methods are used to work directly on profiles / surfaces, cutter objects\ncan be instantiated to apply the same cut to multiple profiles / surfaces</p>\n", "bases": "Cutter, abc.ABC"}, {"fullname": "surfile.cutter.HistCutter.cut", "modulename": "surfile.cutter", "qualname": "HistCutter.cut", "kind": "function", "doc": "<p>Cuts the surface on the Z axis keeping only the\npoints with an height included in the selection</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the cut is applied\nbins : int\n    The number of bins in the histogram\n    if None the program calculates the optimal value\nfinalize: bool\n    If set to False the cut will not alter the profile,\n    the method will only return the extents chosen by the user</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>extents (zmin, zmax):  (float, ...)\n    The cut values</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span>, </span><span class=\"param\"><span class=\"n\">bins</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor", "modulename": "surfile.extractor", "kind": "module", "doc": "<p>'surfile.extractor'</p>\n\n<ul>\n<li>Creates a profile from a surface provides:\n<ul>\n<li>SimpleExtractor: profile parallel to x or y direction</li>\n<li>ComplexExtractor: profile can be any (even pieceWise defined)</li>\n<li>SphereExtractor: profile starting from the maximum point of the surface</li>\n</ul></li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Since the study of profiles is of great interest for studying (i) roughness \nparameters and (ii) height measurements of step or groove samples, profile \nextraction methodologies have been implemented within the program.</p>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.extractor.Extractor", "modulename": "surfile.extractor", "qualname": "Extractor", "kind": "class", "doc": "<p>Class that provides methods for profile extraction from topographies\nstatic methods are used to work directly on surfaces, extractor objects\ncan be instantiated to apply the same extraction to multiple topographies</p>\n\n<p>The provided extraction can be divided into:</p>\n\n<ul>\n<li>simple extraction: the profile is parallel to x or y</li>\n<li>complex extraction: the profile can be any, even peacewise defined</li>\n<li>sphere extraction: the profile is along the x direction but starts from\nthe center of the spherical cup</li>\n</ul>\n", "bases": "abc.ABC"}, {"fullname": "surfile.extractor.Extractor.options", "modulename": "surfile.extractor", "qualname": "Extractor.options", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.extractor.Extractor.points", "modulename": "surfile.extractor", "qualname": "Extractor.points", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.extractor.Extractor.template", "modulename": "surfile.extractor", "qualname": "Extractor.template", "kind": "function", "doc": "<p>Asks the user to open a template topography\nplots the template and asks how to extract a profile.\nThe parameters are saved and used everytime the extractor is\napplied to a topography obj, see apply()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.Extractor.apply", "modulename": "surfile.extractor", "qualname": "Extractor.apply", "kind": "function", "doc": "<p>Applies the extraction to the object passed using the parameters\ndefined previously by the user, see template()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SimpleExtractor", "modulename": "surfile.extractor", "qualname": "SimpleExtractor", "kind": "class", "doc": "<p>Class that provides methods for profile extraction from topographies\nstatic methods are used to work directly on surfaces, extractor objects\ncan be instantiated to apply the same extraction to multiple topographies</p>\n\n<p>The provided extraction can be divided into:</p>\n\n<ul>\n<li>simple extraction: the profile is parallel to x or y</li>\n<li>complex extraction: the profile can be any, even peacewise defined</li>\n<li>sphere extraction: the profile is along the x direction but starts from\nthe center of the spherical cup</li>\n</ul>\n", "bases": "Extractor, abc.ABC"}, {"fullname": "surfile.extractor.SimpleExtractor.template", "modulename": "surfile.extractor", "qualname": "SimpleExtractor.template", "kind": "function", "doc": "<p>Asks the user to open a template topography\nplots the template and asks how to extract a profile.\nThe parameters are saved and used everytime the extractor is\napplied to a topography obj, see apply()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SimpleExtractor.apply", "modulename": "surfile.extractor", "qualname": "SimpleExtractor.apply", "kind": "function", "doc": "<p>Applies the extraction to the object passed using the parameters\ndefined previously by the user, see template()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SimpleExtractor.profile", "modulename": "surfile.extractor", "qualname": "SimpleExtractor.profile", "kind": "function", "doc": "<p>Extracts a profile along x or y at the position indicated by the user</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the profile is extracted\ndirection: str\n    The direction of the profile mean 'x' or 'y'\nwidth: int\n    The lateral number of values averged when extracting the profile\nbplt: bool\n    If True plots the extracted profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>profile: prf.Profile\n    Profile object exctracted from the topography\noptions: dict\n    The position selected by the user and the direction of extraction</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"o\">=</span><span class=\"s1\">&#39;x&#39;</span>, </span><span class=\"param\"><span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SimpleExtractor.meanProfile", "modulename": "surfile.extractor", "qualname": "SimpleExtractor.meanProfile", "kind": "function", "doc": "<p>Extracts the mean profile along x or y</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the profile is extracted\ndirection: str\n    The direction of the profile mean 'x' or 'y'\ncutter: cutter.Cutter\n    -if not set, the fit uses all points\n    -if true allows the user to select manually the region of interest\n    -if a cutter obj is passed the fit is done only on the cutted profile points\n     and then applied on the whole profile\nbplt: bool\n    If True plots the extracted profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>prf: profile.Profile\n    The mean profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"o\">=</span><span class=\"s1\">&#39;x&#39;</span>, </span><span class=\"param\"><span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.ComplexExtractor", "modulename": "surfile.extractor", "qualname": "ComplexExtractor", "kind": "class", "doc": "<p>Class that provides methods for profile extraction from topographies\nstatic methods are used to work directly on surfaces, extractor objects\ncan be instantiated to apply the same extraction to multiple topographies</p>\n\n<p>The provided extraction can be divided into:</p>\n\n<ul>\n<li>simple extraction: the profile is parallel to x or y</li>\n<li>complex extraction: the profile can be any, even peacewise defined</li>\n<li>sphere extraction: the profile is along the x direction but starts from\nthe center of the spherical cup</li>\n</ul>\n", "bases": "Extractor, abc.ABC"}, {"fullname": "surfile.extractor.ComplexExtractor.template", "modulename": "surfile.extractor", "qualname": "ComplexExtractor.template", "kind": "function", "doc": "<p>Asks the user to open a template topography\nplots the template and asks how to extract a profile.\nThe parameters are saved and used everytime the extractor is\napplied to a topography obj, see apply()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.ComplexExtractor.apply", "modulename": "surfile.extractor", "qualname": "ComplexExtractor.apply", "kind": "function", "doc": "<p>Applies the extraction to the object passed using the parameters\ndefined previously by the user, see template()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.ComplexExtractor.profile", "modulename": "surfile.extractor", "qualname": "ComplexExtractor.profile", "kind": "function", "doc": "<p>Opens a plot figure to choose the profile and extracts it\nThe profile is taken with a mpl.widgets.PolygonSelector</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the profile is extracted\nwidth: int\n    The lateral number of values averged when extracting the profile\nbplt: bool\n    If True plots the extracted profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>prf: profile.Profile\n    The extracted profile\npoints: the points selected by the user</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">width</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.extractor.SphereExtractor", "modulename": "surfile.extractor", "qualname": "SphereExtractor", "kind": "class", "doc": "<p>Class that provides methods for profile extraction from topographies\nstatic methods are used to work directly on surfaces, extractor objects\ncan be instantiated to apply the same extraction to multiple topographies</p>\n\n<p>The provided extraction can be divided into:</p>\n\n<ul>\n<li>simple extraction: the profile is parallel to x or y</li>\n<li>complex extraction: the profile can be any, even peacewise defined</li>\n<li>sphere extraction: the profile is along the x direction but starts from\nthe center of the spherical cup</li>\n</ul>\n", "bases": "Extractor, abc.ABC"}, {"fullname": "surfile.extractor.SphereExtractor.sphereProfile", "modulename": "surfile.extractor", "qualname": "SphereExtractor.sphereProfile", "kind": "function", "doc": "<p>Returns the profile starting from the start point on the positive x direction</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface object on wich the profile is extracted\nstartP : str\n    Method used to find the start (x, y) point on the topography\n        'max': the start point corresponds to the maximum Z of the topography\n        'fit': the start point is the center coords of the best fit sphere\n        'center': the start point is the center of the topography\n        'local': the start point is the local maximum closest to the center of the topography\nbplt: bool\n    If True plots the topography and the line where the profile is taken from</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>profile: prof.Profile()\n    The extracted profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">startP</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter", "modulename": "surfile.filter", "kind": "module", "doc": "<p>'surfile.filter'</p>\n\n<ul>\n<li>Applies a filter to a profile or a surface:\n<ul>\n<li>gaussian profile</li>\n<li>gaussian surface</li>\n<li>spline profile</li>\n<li>gaussian robust profile</li>\n</ul></li>\n</ul>\n\n<p>@author: Andrea Giura, Dorothee Hueser</p>\n"}, {"fullname": "surfile.filter.Filter", "modulename": "surfile.filter", "qualname": "Filter", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.filter.Filter.cutoff", "modulename": "surfile.filter", "qualname": "Filter.cutoff", "kind": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "surfile.filter.Filter.applyFilter", "modulename": "surfile.filter", "qualname": "Filter.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.Filter.plotEnvelope", "modulename": "surfile.filter", "qualname": "Filter.plotEnvelope", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Z</span>, </span><span class=\"param\"><span class=\"n\">envelope</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.Filter.plot3DEnvelope", "modulename": "surfile.filter", "qualname": "Filter.plot3DEnvelope", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"n\">Z</span>, </span><span class=\"param\"><span class=\"n\">envelope</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileGaussian", "modulename": "surfile.filter", "qualname": "ProfileGaussian", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.ProfileGaussian.__init__", "modulename": "surfile.filter", "qualname": "ProfileGaussian.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span></span>)</span>"}, {"fullname": "surfile.filter.ProfileGaussian.cutoff", "modulename": "surfile.filter", "qualname": "ProfileGaussian.cutoff", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.filter.ProfileGaussian.applyFilter", "modulename": "surfile.filter", "qualname": "ProfileGaussian.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileGaussian.filter", "modulename": "surfile.filter", "qualname": "ProfileGaussian.filter", "kind": "function", "doc": "<p>Applies to a profile object a gaussian filter ISO 16610-21.\nThe resulting profile is cut at the borders to avoid border effects.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the filter is applied\ncutoff: float\n    The cutoff of the gaussian filter\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileSpline", "modulename": "surfile.filter", "qualname": "ProfileSpline", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.ProfileSpline.__init__", "modulename": "surfile.filter", "qualname": "ProfileSpline.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">beta</span></span>)</span>"}, {"fullname": "surfile.filter.ProfileSpline.cutoff", "modulename": "surfile.filter", "qualname": "ProfileSpline.cutoff", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.filter.ProfileSpline.beta", "modulename": "surfile.filter", "qualname": "ProfileSpline.beta", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.filter.ProfileSpline.applyFilter", "modulename": "surfile.filter", "qualname": "ProfileSpline.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileSpline.filter", "modulename": "surfile.filter", "qualname": "ProfileSpline.filter", "kind": "function", "doc": "<p>Applies to a profile object a gaussian filter ISO 16610-22.\nThe resulting profile is cut at the borders to avoid border effects.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the filter is applied\ncutoff: float\n    The cutoff of the spline filter\nbeta: float\n    The tension parameter of the filter (0 &lt; beta &lt; 1)\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">beta</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileRegression", "modulename": "surfile.filter", "qualname": "ProfileRegression", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.ProfileRegression.__init__", "modulename": "surfile.filter", "qualname": "ProfileRegression.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span></span>)</span>"}, {"fullname": "surfile.filter.ProfileRegression.cutoff", "modulename": "surfile.filter", "qualname": "ProfileRegression.cutoff", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.filter.ProfileRegression.applyFilter", "modulename": "surfile.filter", "qualname": "ProfileRegression.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileRegression.filter_matrix", "modulename": "surfile.filter", "qualname": "ProfileRegression.filter_matrix", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.ProfileRegression.filter_regression_p1", "modulename": "surfile.filter", "qualname": "ProfileRegression.filter_regression_p1", "kind": "function", "doc": "<p>Applies to a profile object a gaussian regression with a degree 1 poly.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the filter is applied\ncutoff: float\n    The cutoff of the gaussian filter\nbplt: bool\n    Plots the envelope of the filter if true\nThe use of this function requires the following citacion:\n    Seewig, Linear and robust Gaussian regression filters,\n    2005 J. Phys.: Conf. Ser. 13 254, doi:10.1088/1742-6596/13/1/059</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.TipCorrection", "modulename": "surfile.filter", "qualname": "TipCorrection", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.TipCorrection.filter", "modulename": "surfile.filter", "qualname": "TipCorrection.filter", "kind": "function", "doc": "<p>Tip correction method implementation,\nrolls a disk  of radius R (in mm) along the original profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the filter is applied\nradius: float\n    The radius of the sphere of the contact instrument\nbplt: bool\n    Plots the envelope of the filter if true</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p><span style=\"color:orange\">This function will be moved to a utility module in the future\nuse with caution !!!</span>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.TipCorrection.naive", "modulename": "surfile.filter", "qualname": "TipCorrection.naive", "kind": "function", "doc": "<p>Tip correction implementation,\nrolls a disk  of radius R (in mm) along the original profile\nUses the naive approach described in:\n\"Algorithms for morph profile filters and their comparison\"\nShan Lou, Xiangqian Jiang, Paul J. Scott. (2012)</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the filter is applied\nradius: float\n    The radius of the sphere of the contact instrument\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">radius</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.SurfaceGaussian", "modulename": "surfile.filter", "qualname": "SurfaceGaussian", "kind": "class", "doc": "<p></p>\n", "bases": "Filter"}, {"fullname": "surfile.filter.SurfaceGaussian.__init__", "modulename": "surfile.filter", "qualname": "SurfaceGaussian.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">cutoff</span></span>)</span>"}, {"fullname": "surfile.filter.SurfaceGaussian.cutoff", "modulename": "surfile.filter", "qualname": "SurfaceGaussian.cutoff", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.filter.SurfaceGaussian.applyFilter", "modulename": "surfile.filter", "qualname": "SurfaceGaussian.applyFilter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.filter.SurfaceGaussian.filter", "modulename": "surfile.filter", "qualname": "SurfaceGaussian.filter", "kind": "function", "doc": "<p>Applies to a surface object a gaussian filter ISO 16610-21.\nApplies to a surface object a gaussian filter ISO 16610-21.\nThe resulting profile is cut at the borders to avoid border effects.\nTODO !!!</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the filter is applied\ncutoff: float\n    The cutoff of the gaussian filter\nbplt: bool\n    Plots the envelope of the filter if true</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">cutoff</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct", "modulename": "surfile.funct", "kind": "module", "doc": "<p>'surfile.funct'</p>\n\n<ul>\n<li>utility functions</li>\n<li>decorators for automation and code reusage</li>\n</ul>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.funct.Bcol", "modulename": "surfile.funct", "qualname": "Bcol", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.funct.Bcol.HEADER", "modulename": "surfile.funct", "qualname": "Bcol.HEADER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[95m&#x27;"}, {"fullname": "surfile.funct.Bcol.OKBLUE", "modulename": "surfile.funct", "qualname": "Bcol.OKBLUE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[94m&#x27;"}, {"fullname": "surfile.funct.Bcol.OKCYAN", "modulename": "surfile.funct", "qualname": "Bcol.OKCYAN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[96m&#x27;"}, {"fullname": "surfile.funct.Bcol.OKGREEN", "modulename": "surfile.funct", "qualname": "Bcol.OKGREEN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[92m&#x27;"}, {"fullname": "surfile.funct.Bcol.WARNING", "modulename": "surfile.funct", "qualname": "Bcol.WARNING", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[93m&#x27;"}, {"fullname": "surfile.funct.Bcol.FAIL", "modulename": "surfile.funct", "qualname": "Bcol.FAIL", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[91m&#x27;"}, {"fullname": "surfile.funct.Bcol.ENDC", "modulename": "surfile.funct", "qualname": "Bcol.ENDC", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[0m&#x27;"}, {"fullname": "surfile.funct.Bcol.BOLD", "modulename": "surfile.funct", "qualname": "Bcol.BOLD", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[1m&#x27;"}, {"fullname": "surfile.funct.Bcol.UNDERLINE", "modulename": "surfile.funct", "qualname": "Bcol.UNDERLINE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\x1b[4m&#x27;"}, {"fullname": "surfile.funct.persFig", "modulename": "surfile.funct", "qualname": "persFig", "kind": "function", "doc": "<p>Personalize an axis object or multiple</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>figures: list\n    The list of ax objects to be customized\ngridcol: str\n    The color of the grid, use None to remove the grid\nxlab: str\nylab: str\nzlab: str</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">figures</span>, </span><span class=\"param\"><span class=\"n\">xlab</span>, </span><span class=\"param\"><span class=\"n\">ylab</span>, </span><span class=\"param\"><span class=\"n\">zlab</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">gridcol</span><span class=\"o\">=</span><span class=\"s1\">&#39;k&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.nan_helper", "modulename": "surfile.funct", "qualname": "nan_helper", "kind": "function", "doc": "<p>Helper to handle indices and logical indices of NaNs.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>y : np.array\n    1d numpy array with possible NaNs</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>nans : np.array\n    logical indices of NaNs\nindex : funct\n    a function, with signature indices= index(logical_indices),\n    to convert logical indices of NaNs to 'equivalent' indices</p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># linear interpolation of NaNs</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">nans</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"o\">=</span> <span class=\"n\">nan_helper</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"n\">nans</span><span class=\"p\">]</span><span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">interp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"n\">nans</span><span class=\"p\">),</span> <span class=\"n\">x</span><span class=\"p\">(</span><span class=\"o\">~</span><span class=\"n\">nans</span><span class=\"p\">),</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">nans</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.options", "modulename": "surfile.funct", "qualname": "options", "kind": "function", "doc": "<p>Decorator that implements global configurations</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>csvPath: str\n    If not none saves the return parameters of the decorated function to a csv\nsave: str\n    If not none saves the figures in the path\nbplt: bool\n    If True shows the images\nchrono: bool\n    If true times the duration of the decorated function</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Use this decorator only on methods that do not call plt.show</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">csvPath</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">save</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">chrono</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.classOptions", "modulename": "surfile.funct", "qualname": "classOptions", "kind": "function", "doc": "<p>Class decorator uset to apply the same @dec to all methods</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">decorator</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.Rc", "modulename": "surfile.funct", "qualname": "Rc", "kind": "class", "doc": "<p>Class used to define the options of the decorators</p>\n\n<p>Parameters convention: each parameter has:</p>\n\n<ul>\n<li>1 letter indentifying the option\n<ul>\n<li>c: csv</li>\n<li>s: save the image</li>\n<li>b: bplt</li>\n<li>t: chrono</li>\n</ul></li>\n<li>1 letter identifying the type\n<ul>\n<li>s: surface</li>\n<li>p: profile</li>\n</ul></li>\n<li>3 chars identifying the decorated function</li>\n</ul>\n"}, {"fullname": "surfile.funct.Rc.params", "modulename": "surfile.funct", "qualname": "Rc.params", "kind": "variable", "doc": "<p></p>\n", "annotation": ": dict"}, {"fullname": "surfile.funct.Rc.currentImage", "modulename": "surfile.funct", "qualname": "Rc.currentImage", "kind": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": "&#x27;&#x27;"}, {"fullname": "surfile.funct.Rc.load", "modulename": "surfile.funct", "qualname": "Rc.load", "kind": "function", "doc": "<p>Loads a user defined rc parameters file</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>js_fin: str\n    The json file name</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">js_fin</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.Rc.store", "modulename": "surfile.funct", "qualname": "Rc.store", "kind": "function", "doc": "<p>Saves the current parameters to a file</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>js_fout: str\n    The json file name</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">js_fout</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.Rc.setCurrentImage", "modulename": "surfile.funct", "qualname": "Rc.setCurrentImage", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.funct.rcs", "modulename": "surfile.funct", "qualname": "rcs", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;surfile.funct.Rc object&gt;"}, {"fullname": "surfile.geometry", "modulename": "surfile.geometry", "kind": "module", "doc": "<p>'surfile.geometry'</p>\n\n<ul>\n<li>form fit operations, implements:\n<ul>\n<li>circle fit</li>\n<li>least square polynomial fits with bounded domain</li>\n<li>3 point plane</li>\n<li>spherical fit</li>\n<li>cylinder fit</li>\n</ul></li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Measurements made by microscopy techniques involve sample loading,\nand specifically profilometers involve the housing of samples above a tilt x-y table.\nBefore carrying out the measurements, the samples must be levelled with respect to \nthe instrument plane, but since the images recorded have distortions mainly due \nto misalignments (since the plane which contains the sample surface is not perfectly \nparallel to the plane of the image), it is therefore essential to implement methods \nfor image levelling.  Moreover, other image distortions which can degrade the quality \nof the surface reconstruction are (i) bow, which appears as a false curvature superposed \non the real sample topography, and (ii) edge effects, that can enlarge or shrink \nfeatures present in the image borders.</p>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.geometry.FormEstimator", "modulename": "surfile.geometry", "qualname": "FormEstimator", "kind": "class", "doc": "<p>Base class for form fitting operations contains the methods \ncommon to all the derived classes:</p>\n\n<ul>\n<li>Profile Line</li>\n<li>Profile Poly</li>\n<li>Circle</li>\n<li>Surface Plane</li>\n<li>Surface Poly</li>\n<li>Surface 3 Points</li>\n<li>Sphere</li>\n<li>Cylinder</li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The form or geometry parameters are estimated by minimizing the sum of the squares\nof the residuals: $\\varepsilon_i \\; = \\; f(\\mathbf{p}, x_i, y_i, z_i)$\nwhere $(x_i, y_i)$ are the sampling positions, $z_i = z(x_i, y_i)$ are the height values \nof the topography map, $f$ is the model function, and $\\mathbf{p} = [p_0, p_1, \\dots, p_m]$ \nis the tuple of geometry parameters or polynomial coefficients to be estimated by optimization.</p>\n\n<p>$\\min_{\\mathbf{p}} {\\sum\\limits_{i = 0}^{n-1}  f(\\mathbf{p}, x_i, y_i, z_i)^2 }$</p>\n"}, {"fullname": "surfile.geometry.FormEstimator.applyFit", "modulename": "surfile.geometry", "qualname": "FormEstimator.applyFit", "kind": "function", "doc": "<p>Applies the fit operation to the obj with the\nparameters of the self object</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surfile.container\n    The data structure\nbplt : bool, optional\n    If true plots the removed form, by default False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.FormEstimator.plotForm", "modulename": "surfile.geometry", "qualname": "FormEstimator.plotForm", "kind": "function", "doc": "<p>Plots the fitted 1d function and the profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : np.array\n    The x values of the profile\nz : np.array\n    The z values of the profile\ncoeff : np.array\n    The coefficients of the polynomial fit</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">coeff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.FormEstimator.removeForm", "modulename": "surfile.geometry", "qualname": "FormEstimator.removeForm", "kind": "function", "doc": "<p>Calculates the polynomial function given the\ncoefficients and subtracts the form from the profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : np.array\n    The x values of the profile\nz : np.array\n    The z values of the profile\ncoeff : np.array\n    The coefficients of the polynomial fit</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>z_final : np.array\n    The final z values of the profile after the form is removed</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">coeff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.FormEstimator.plot3DForm", "modulename": "surfile.geometry", "qualname": "FormEstimator.plot3DForm", "kind": "function", "doc": "<p>Plots the fitted 2d function and the surface</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : np.array\n    The x values of the surface\ny : np.array\n    The y values of the surface\nz : np.array\n    The z values of the surface\ncoeff : np.array\n    The coefficients of the polynomial fit</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">coeff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.FormEstimator.remove3DForm", "modulename": "surfile.geometry", "qualname": "FormEstimator.remove3DForm", "kind": "function", "doc": "<p>Removes the fitted 2d function from the surface</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : np.array\n    The x values of the surface\ny : np.array\n    The y values of the surface\nz : np.array\n    The z values of the surface\ncoeff : np.array\n    The coefficients of the polynomial fit</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>z_final : np.array\n    The final z values of the surface after the form is removed</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">coeff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.ProfileLSLine", "modulename": "surfile.geometry", "qualname": "ProfileLSLine", "kind": "class", "doc": "<p>Class derived from FormEstimator for the degree 1 line \nfit on a profile data.</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.ProfileLSLine.applyFit", "modulename": "surfile.geometry", "qualname": "ProfileLSLine.applyFit", "kind": "function", "doc": "<p>Applies the fit operation to the obj with the\nparameters of the self object</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surfile.container\n    The data structure\nbplt : bool, optional\n    If true plots the removed form, by default False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.ProfileLSLine.formFit", "modulename": "surfile.geometry", "qualname": "ProfileLSLine.formFit", "kind": "function", "doc": "<p>Least square line fit implementation on a profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : profile.Profile\n    The profile object on wich the form is removed\nbplt : bool\n    If True plots the line overimposed on the profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(m, q) : (float, ...)\n    The line equation coefficients</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>$\\min_{\\mathbf{p}} {\\sum\\limits_{i = 0}^{n-1}  f(\\mathbf{p}, x_i, z_i)^2 }$</p>\n\n<p>In this particular case of line fitting $f(\\mathbf{p}, x_i, z_i)=z_i-z(\\mathbf{p}, x_i)$\nwhere $z(\\mathbf{p}, x)=p_0 x + p_1$ and $\\mathbf{p}=[m, q]$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.ProfilePolynomial", "modulename": "surfile.geometry", "qualname": "ProfilePolynomial", "kind": "class", "doc": "<p>Class derived from FormEstimator for the degree n polynomial \nfit on a profile data.</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.ProfilePolynomial.__init__", "modulename": "surfile.geometry", "qualname": "ProfilePolynomial.__init__", "kind": "function", "doc": "<p>Creates a ProfilePolynomial object with the parameters provided</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>degree: int\n    polynomial degree\ncomp: funct / lambda\n    comparison method between bound and profile\nbound: float\n    -if not set the fit uses all points,\n    -if set the fit uses all points below the value,\n    -if set to True the fit uses only the values below the average value of the profile\ncutter: cutter.Cutter\n    -if not set, the fit uses all points\n    -if true allows the user to select manually the region of interest\n    -if a cutter obj is passed the fit is done only on the cutted profile points\n     and then applied on the whole profile</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">profPolyFit</span> <span class=\"o\">=</span> <span class=\"n\">ProfilePolynomial</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">texture</span><span class=\"o\">.</span><span class=\"n\">Parameters</span><span class=\"o\">.</span><span class=\"n\">calc</span><span class=\"p\">(</span><span class=\"n\">prf</span><span class=\"p\">,</span> <span class=\"n\">rem</span><span class=\"o\">=</span><span class=\"n\">profPolyFit</span><span class=\"p\">,</span> <span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">degree</span>,</span><span class=\"param\">\t<span class=\"n\">comp</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">ProfilePolynomial</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "surfile.geometry.ProfilePolynomial.degree", "modulename": "surfile.geometry", "qualname": "ProfilePolynomial.degree", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.ProfilePolynomial.comp", "modulename": "surfile.geometry", "qualname": "ProfilePolynomial.comp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.ProfilePolynomial.bound", "modulename": "surfile.geometry", "qualname": "ProfilePolynomial.bound", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.ProfilePolynomial.cutter", "modulename": "surfile.geometry", "qualname": "ProfilePolynomial.cutter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.ProfilePolynomial.applyFit", "modulename": "surfile.geometry", "qualname": "ProfilePolynomial.applyFit", "kind": "function", "doc": "<p>Applies the fit operation to the obj with the\nparameters of the self object</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surfile.container\n    The data structure\nbplt : bool, optional\n    If true plots the removed form, by default False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.ProfilePolynomial.formFit", "modulename": "surfile.geometry", "qualname": "ProfilePolynomial.formFit", "kind": "function", "doc": "<p>Plynomial fit implementation on a profile using the least square method</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the form is removed\ndegree: int\n    polynomial degree\ncomp: funct / lambda\n    comparison method between bound and profile\nbound: float\n    -if not set the fit uses all points,\n    -if set the fit uses all points below the value,\n    -if set to True the fit uses only the values below the average value of the profile\ncutter: cutter.Cutter\n    -if not set, the fit uses all points\n    -if true allows the user to select manually the region of interest\n    -if a cutter obj is passed the fit is done only on the cutted profile points\n     and then applied on the whole profile\nbplt: bool\n    If True plots the polynomial form overimposed on the profile</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>coeff: np.array()\n    The polynomial form coefficients</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>$\\min_{\\mathbf{p}} {\\sum\\limits_{i = 0}^{n-1}  f(\\mathbf{p}, x_i, z_i)^2 }$</p>\n\n<p>In this particular case of polynomial fitting $f(\\mathbf{p}, x_i, z_i)=z_i-z(\\mathbf{p}, x_i)$\nwhere $z(\\mathbf{p}, x)=p_0 x^n + \\cdots + p_{n-1} x + p_n$ and $\\mathbf{p}=[p_0, \\cdots, p_n]$.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>,</span><span class=\"param\">\t<span class=\"n\">degree</span>,</span><span class=\"param\">\t<span class=\"n\">comp</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">ProfilePolynomial</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.Circle", "modulename": "surfile.geometry", "qualname": "Circle", "kind": "class", "doc": "<p>Class derived from FormEstimator for the circle \nfit on a profile data.</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.Circle.formFit", "modulename": "surfile.geometry", "qualname": "Circle.formFit", "kind": "function", "doc": "<p>Circle fit implementation using the least square method</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the form is removed\ncutter: cutter.Cutter\n    -if not set, the fit uses all points\n    -if true allows the user to select manually the region of interest\n    -if a cutter obj is passed the fit is done only on the cutted profile points\n     and then applied on the whole profile\nfinalize: bool\n    If set to False the fit will not alter the surface,\n    the method will only return the radius and the form deviation\nbplt: bool\n    Plots the sphere fitted to the data points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>r: float\n    The radius of the fitted circle\ndev: float\n    The form deviation of the points\n(xc, zc) : tuple\n    Centre coordinates</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The method used is from circle-fit python package hyperLSQ()\nwhich implements the algorithm in [1]</p>\n\n<h2 id=\"references\">References</h2>\n\n<p>[1] Rangarajan, Prasanna &amp; Kanatani, Kenichi &amp; Niitsuma, Hirotaka &amp; Sugaya, Yasuyuki. (2010). \nHyper Least Squares and Its Applications. 5-8. 10.1109/ICPR.2010.10.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.ProfileStitchError", "modulename": "surfile.geometry", "qualname": "ProfileStitchError", "kind": "class", "doc": "<p>Base class for form fitting operations contains the methods \ncommon to all the derived classes:</p>\n\n<ul>\n<li>Profile Line</li>\n<li>Profile Poly</li>\n<li>Circle</li>\n<li>Surface Plane</li>\n<li>Surface Poly</li>\n<li>Surface 3 Points</li>\n<li>Sphere</li>\n<li>Cylinder</li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The form or geometry parameters are estimated by minimizing the sum of the squares\nof the residuals: $\\varepsilon_i \\; = \\; f(\\mathbf{p}, x_i, y_i, z_i)$\nwhere $(x_i, y_i)$ are the sampling positions, $z_i = z(x_i, y_i)$ are the height values \nof the topography map, $f$ is the model function, and $\\mathbf{p} = [p_0, p_1, \\dots, p_m]$ \nis the tuple of geometry parameters or polynomial coefficients to be estimated by optimization.</p>\n\n<p>$\\min_{\\mathbf{p}} {\\sum\\limits_{i = 0}^{n-1}  f(\\mathbf{p}, x_i, y_i, z_i)^2 }$</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.ProfileStitchError.remove", "modulename": "surfile.geometry", "qualname": "ProfileStitchError.remove", "kind": "function", "doc": "<p>Adjust the profile to preserve the derivative in the stitching.py points</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile on wich the correction is calculated\nstitchPos: np.array\n    The x positions of the stitching.py\nbplt: bool\n    Plots the comparison between the corrected profile and the original</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">stitchPos</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.ProfileHistogram", "modulename": "surfile.geometry", "qualname": "ProfileHistogram", "kind": "class", "doc": "<p>Base class for form fitting operations contains the methods \ncommon to all the derived classes:</p>\n\n<ul>\n<li>Profile Line</li>\n<li>Profile Poly</li>\n<li>Circle</li>\n<li>Surface Plane</li>\n<li>Surface Poly</li>\n<li>Surface 3 Points</li>\n<li>Sphere</li>\n<li>Cylinder</li>\n</ul>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The form or geometry parameters are estimated by minimizing the sum of the squares\nof the residuals: $\\varepsilon_i \\; = \\; f(\\mathbf{p}, x_i, y_i, z_i)$\nwhere $(x_i, y_i)$ are the sampling positions, $z_i = z(x_i, y_i)$ are the height values \nof the topography map, $f$ is the model function, and $\\mathbf{p} = [p_0, p_1, \\dots, p_m]$ \nis the tuple of geometry parameters or polynomial coefficients to be estimated by optimization.</p>\n\n<p>$\\min_{\\mathbf{p}} {\\sum\\limits_{i = 0}^{n-1}  f(\\mathbf{p}, x_i, y_i, z_i)^2 }$</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.ProfileHistogram.remove", "modulename": "surfile.geometry", "qualname": "ProfileHistogram.remove", "kind": "function", "doc": "<p>Alligns the profile using the recursive histogram method, stops when\nthe tilt correction is less than the parameter final_m</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile object on wich the form is removed\nfinal_m: float\n    The end slope correction\nbplt: bool\n    Plots the histogram evolution over the iterations</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>, </span><span class=\"param\"><span class=\"n\">final_m</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.SurfaceLSPlane", "modulename": "surfile.geometry", "qualname": "SurfaceLSPlane", "kind": "class", "doc": "<p>Class derived from FormEstimator for the degree 1 plane \nfit on surface data.</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.SurfaceLSPlane.applyFit", "modulename": "surfile.geometry", "qualname": "SurfaceLSPlane.applyFit", "kind": "function", "doc": "<p>Applies the fit operation to the obj with the\nparameters of the self object</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surfile.container\n    The data structure\nbplt : bool, optional\n    If true plots the removed form, by default False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.SurfaceLSPlane.formFit", "modulename": "surfile.geometry", "qualname": "SurfaceLSPlane.formFit", "kind": "function", "doc": "<p>Least square plane fit implementation</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the LS plane is applied\nbplt : bool\n    If True plots the plane overimposed on the surface</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sol : np.ndarray\n    Array of polynomial coefficients.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>$\\min_{\\mathbf{p}} {\\sum\\limits_{i = 0}^{n-1}  f(\\mathbf{p}, x_i, y_i, z_i)^2 }$</p>\n\n<p>In this particular case of plane fitting $f(\\mathbf{p}, x_i, y_i, z_i)=z_i-z(\\mathbf{p}, x_i, y_i)$\nwhere $z(\\mathbf{p}, x, y)=p_{0,1} x + p_{1,0} y + p_{0,0}$ and \n$\\mathbf{p}=[[p_{0,0}, p_{0,1}][p_{1,0}, \\textcolor{red}{p_{1,1}}]]$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.SurfacePolynomial", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial", "kind": "class", "doc": "<p>Class derived from FormEstimator for the degree kx, ky polynomial \nfit on surface data.</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.SurfacePolynomial.__init__", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial.__init__", "kind": "function", "doc": "<p>Creates a SurfacePolynomial object with the parameters provided</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>kx, ky : int\n    Polynomial order in x and y, respectively.\nfull : bool, optional\n    If True, will solve using the full polynomial matrix.  Otherwise,\n    will use the upper-left triangle of the matrix.  See\n    <code>polyinterp2d</code> for further details.  Note that if kx != ky, then\n    the full matrix will be solved for. (@sofia_redux/toolkit)\ncomp : funct / lambda, optional\n    comparison method between bound and surface\nbound: float, optional\n    if not set the fit uses all points,\n    if set the fit uses all points below the values,\n    if set to True the fit uses only the values below the average value of the surface\ncutter : cutter.Cutter\n    -if not set, the fit uses all points\n    -if true allows the user to select manually the region of interest\n    -if a cutter obj is passed the fit is done only on the cutted profile points\n     and then applied on the whole profile</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kx</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">ky</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">full</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">comp</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">SurfacePolynomial</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "surfile.geometry.SurfacePolynomial.kx", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial.kx", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.SurfacePolynomial.ky", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial.ky", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.SurfacePolynomial.full", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial.full", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.SurfacePolynomial.comp", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial.comp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.SurfacePolynomial.bound", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial.bound", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.SurfacePolynomial.cutter", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial.cutter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.geometry.SurfacePolynomial.applyFit", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial.applyFit", "kind": "function", "doc": "<p>Applies the fit operation to the obj with the\nparameters of the self object</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surfile.container\n    The data structure\nbplt : bool, optional\n    If true plots the removed form, by default False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.SurfacePolynomial.formFit", "modulename": "surfile.geometry", "qualname": "SurfacePolynomial.formFit", "kind": "function", "doc": "<p>Least square polynomial fit implementation on surface data</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the polynomial fit is applied\nkx, ky : int\n    Polynomial order in x and y, respectively.\nfull : bool, optional\n    If True, will solve using the full polynomial matrix.  Otherwise,\n    will use the upper-left triangle of the matrix.  See\n    <code>polyinterp2d</code> for further details.  Note that if kx != ky, then\n    the full matrix will be solved for. (@sofia_redux/toolkit)\ncomp : funct / lambda, optional\n    comparison method between bound and surface\nbound : float, optional\n    if not set the fit uses all points,\n    if set the fit uses all points below the values,\n    if set to True the fit uses only the values below the average value of the surface\ncutter : cutter.Cutter\n    -if not set, the fit uses all points\n    -if true allows the user to select manually the region of interest\n    -if a cutter obj is passed the fit is done only on the cutted profile points\n     and then applied on the whole profile\nbplt: bool, optional\n    If True plots the plane overimposed on the surface</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sol : np.ndarray\n    Array of polynomial coefficients.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>$\\min_{\\mathbf{p}} {\\sum\\limits_{i = 0}^{n-1}  f(\\mathbf{p}, x_i, y_i, z_i)^2 }$</p>\n\n<p>In this particular case of polynomial fitting $f(\\mathbf{p}, x_i, y_i, z_i)=z_i-z(\\mathbf{p}, x_i, y_i)$\nwhere $z(\\mathbf{p}, x, y)=\\sum_{i,j}p_{i,j}\\cdot x^i \\cdot y^j$ and \n$\\mathbf{M}=[\n[m_{0,0},  \\cdots,  m_{0,kx}]\n[\\vdots,  \\ddots,  \\textcolor{red}{\\vdots}]\n[m_{ky,0},  \\textcolor{red}{\\cdots},  \\textcolor{red}{m_{kx,ky}}]\n]$.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>,</span><span class=\"param\">\t<span class=\"n\">kx</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">ky</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">full</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">comp</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">SurfacePolynomial</span><span class=\"o\">.&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cutter</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.Surface3Points", "modulename": "surfile.geometry", "qualname": "Surface3Points", "kind": "class", "doc": "<p>Class derived from FormEstimator for the removal of the\nplane defined by three points selected by the user.</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.Surface3Points.remove", "modulename": "surfile.geometry", "qualname": "Surface3Points.remove", "kind": "function", "doc": "<p>3 points plane fit implementation\nOpens a plot figure to choose the 3 points and finds the equation\nof the plane passing through those 3 points.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the polynomial fit is applied\nbplt : bool\n    If True plots the plane overimposed on the surface</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Once the choice has been confirmed, the program calculates the coefficients \na, b and c of the equation of the plane $z_{plane}(x,y)$  passing through the \nthree specified positions Pa, Pb and Pc.</p>\n\n<p>Points coordinates:\n$P_a=(x_a, y_a, z_a)$\n$P_b=(x_b, y_b, z_b)$\n$P_c=(x_c, y_c, z_c)$</p>\n\n<p>Plane coefficients:\n$a=(y_b-y_a)(z_c-z_a)-(y_c-y_a)(z_b-z_a)$\n$b=(x_c-x_a)(z_b-z_a)-(x_b-x_a)(z_c-z_a)$\n$c=(x_b-x_a)(y_c-y_a)-(y_b-y_a)(x_c-x_a)$</p>\n\n<p>Plane equation:\n$z_{plane}(x,y)=\\frac{(-ax-by)}{c}$</p>\n\n<p>NOTE: in order to let the software perform a robust and affordable calculation, \nthe chosen points Pa, Pb and Pc must be as far apart as possible \n(if possible, as vertices of an equilateral triangle)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.Sphere", "modulename": "surfile.geometry", "qualname": "Sphere", "kind": "class", "doc": "<p>Class derived from FormEstimator for the removal of the\nleast square sphere</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.Sphere.formFit", "modulename": "surfile.geometry", "qualname": "Sphere.formFit", "kind": "function", "doc": "<p>Calculates the least square sphere</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the polynomial fit is applied\nfinalize : bool\n    If set to False the fit will not alter the surface,\n    the method will only return the center and the radius\nradius : float\n    If None the method will use the best fit radius\n    If a radius is passed then the program will use it\nconcavity : str\n    Can be either 'convex' or 'concave'\n    If set to None the program will find the concavity of the sample\nbplt : bool\n    Plots the sphere fitted to the data points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(radius, C): (float, [xc, yc, zc])\n    Radius and sphere center coordinates</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The general equation of a sphere is: $(x-x_c)^2+(y-y_c)^2+(z-z_c)^2=r^2$</p>\n\n<p>Expanding the equation we get: $x^2+y^2+z^2=2xx_c+2yy_c+2zz_c+r^2-x_c^2-y_c^2-z_c^2$ <br />\nWe can solve for $x_c, y_c, z_c, r$</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>,</span><span class=\"param\">\t<span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">concavity</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.geometry.Cylinder", "modulename": "surfile.geometry", "qualname": "Cylinder", "kind": "class", "doc": "<p>Class derived from FormEstimator for the calculation of the\nleast square cylinder</p>\n", "bases": "FormEstimator"}, {"fullname": "surfile.geometry.Cylinder.formFit", "modulename": "surfile.geometry", "qualname": "Cylinder.formFit", "kind": "function", "doc": "<p>This is a fitting for a horizontal along x cylinder fitting\nuses the following parameters to find the best cylinder fit</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj : surface.Surface\n    The surface object on wich the cylinder fit is applied\nradius : float\n    The cylinder nominal radius\nalphaY : float\n    An estimate ot the cylinder rotation about the y-axis (radian)\nalphaZ : float\n    An estimate ot the cylinder rotation about the z-axis (radian)\nconcavity : str\n    Can be either 'convex' or 'concave'\nbase : bool\n    If true removes the points at the base of the cylinder\nfinalize : bool\n    If set to False the fit will not alter the surface,\n    the method will only return the center and the radius\nbplt : bool\n    Plots the sphere fitted to the data points</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>est_p : np.array\n    P[0] = r, radius of the cylinder</p>\n\n<pre><code>p[1] = Yc, y coordinate of the cylinder centre\n\nP[2] = Zc, z coordinate of the cylinder centre\n\nP[3] = alpha_z, rotation angle (radian) about the z-axis\n\nP[4] = alpha_y, rotation angle (radian) about the y-axis\n</code></pre>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The cylinder fit is done according to the general cylider equation with 5\ndegrees of freedom to accomodate for the axis rotation and translation.\nThe general equation of the cylinder is $(x-x_c)^2+(y-y_c)^2+(z-z_c)^2-[l(x-x_c)+m(y-y_c)+n(z_{cyl}-z_c)]^2-R^2=0$\nWhere $x,y,z_{cyl}$ are the coordinates of the cylinder points, $l, m, n$ \nare the three components of the versor that represent the cylinder axis direction,\n$x_c, y_c, z_c$ are the coordinate of the centre and $R$ is the radius of the circular base.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span>,</span><span class=\"param\">\t<span class=\"n\">alphaZ</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">alphaY</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">concavity</span><span class=\"o\">=</span><span class=\"s1\">&#39;convex&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">base</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">finalize</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io", "modulename": "surfile.measfile_io", "kind": "module", "doc": "<p>'surfile.measfile_io'\nModule to read data output of microscopes:</p>\n\n<ul>\n<li>Olympus Lext</li>\n<li>Sensofar plu</li>\n<li>Asylum Cypher ibw</li>\n<li>Digital Surf sur</li>\n<li>SPIP bcr and bcrf</li>\n<li>ISO 25178-71 sdf</li>\n<li>NMM (Gaoliang)</li>\n<li>asc tracOptic data file</li>\n<li>txt (xyz or space Z)</li>\n</ul>\n\n<p>Created 2019-10-03\nlast edit 2024-02-09\n@author: Dorothee Hueser</p>\n"}, {"fullname": "surfile.measfile_io.withigor", "modulename": "surfile.measfile_io", "qualname": "withigor", "kind": "variable", "doc": "<p></p>\n", "default_value": "0"}, {"fullname": "surfile.measfile_io.read_microscopedata", "modulename": "surfile.measfile_io", "qualname": "read_microscopedata", "kind": "function", "doc": "<p>Main function that reads from files according to the file extension</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>filename : String\n    The path of the file\nuserscalecorr : np.array\n    [x, y, z] vector of correction values\ninterpolflag : Bool\n    If true fills the non measured points with spline interpolation</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dx : float\n    The x spacing\ndy : float\n    The y spacing\nheight_map : np.array\n    The Z array</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">userscalecorr</span>, </span><span class=\"param\"><span class=\"n\">interpolflag</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.str2float", "modulename": "surfile.measfile_io", "qualname": "str2float", "kind": "function", "doc": "<p>Convert string to float without stopping at an error</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>In txt files the nan values are represented with\na non numerical value and the numpy reading routines \noften fail and terminate the program. This function\nis used in case of reading failure to insert a NaN value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.extract_tag", "modulename": "surfile.measfile_io", "qualname": "extract_tag", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sdata</span>, </span><span class=\"param\"><span class=\"n\">tagkey</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_spaceZtxt", "modulename": "surfile.measfile_io", "qualname": "read_spaceZtxt", "kind": "function", "doc": "<p>Reads a txt file with spacing values on the top \ntwo lines and then the list of Z values of the array.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : string\n    The file path to open</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(X, Y, Z, x, y) : tuple\n    The arrays red from the file</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_xyztxt", "modulename": "surfile.measfile_io", "qualname": "read_xyztxt", "kind": "function", "doc": "<p>Reads a txt file with three columns [x, y, z]</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : string\n    The file path to open</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(X, Y, Z, x, y) : tuple\n    The arrays red from the file</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_asc", "modulename": "surfile.measfile_io", "qualname": "read_asc", "kind": "function", "doc": "<p>Reads the tracoptic project file structure</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filecontent</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_lextinfo", "modulename": "surfile.measfile_io", "qualname": "read_lextinfo", "kind": "function", "doc": "<p>read factor to convert raw data values into values in micron</p>\n\n<p>parameter:\nfilecontent: binary content of complete file</p>\n\n<p>return:\nnx, ny: number of data points/ pixel for each direction\nendheightmap: byte position of end of height map\nheightperpix: factor to be multiplied to raw data to obtain micron\nmagnification: of objective lens\nmeasdate: date an time when data where aquired with instrument</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filecontent</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_lextimg", "modulename": "surfile.measfile_io", "qualname": "read_lextimg", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">nx</span>, </span><span class=\"param\"><span class=\"n\">ny</span>, </span><span class=\"param\"><span class=\"n\">endheightmap</span>, </span><span class=\"param\"><span class=\"n\">heightflag</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_plu", "modulename": "surfile.measfile_io", "qualname": "read_plu", "kind": "function", "doc": "<p>Read sensofar data files</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filecontent</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_ibw", "modulename": "surfile.measfile_io", "qualname": "read_ibw", "kind": "function", "doc": "<p>Read cypher data</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_asciisdf", "modulename": "surfile.measfile_io", "qualname": "read_asciisdf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_sdf", "modulename": "surfile.measfile_io", "qualname": "read_sdf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_bcrf", "modulename": "surfile.measfile_io", "qualname": "read_bcrf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_sur", "modulename": "surfile.measfile_io", "qualname": "read_sur", "kind": "function", "doc": "<p>Read mountains files</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_NMMgaoliang", "modulename": "surfile.measfile_io", "qualname": "read_NMMgaoliang", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.identifybadborderlines", "modulename": "surfile.measfile_io", "qualname": "identifybadborderlines", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zval2d</span>, </span><span class=\"param\"><span class=\"n\">ny</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.interpol_csaps", "modulename": "surfile.measfile_io", "qualname": "interpol_csaps", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zmatrix</span>, </span><span class=\"param\"><span class=\"n\">wmatrix</span>, </span><span class=\"param\"><span class=\"n\">dx</span>, </span><span class=\"param\"><span class=\"n\">dy</span>, </span><span class=\"param\"><span class=\"n\">smoothparam</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.invalid_data_weight", "modulename": "surfile.measfile_io", "qualname": "invalid_data_weight", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">height_map</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_lextintensity", "modulename": "surfile.measfile_io", "qualname": "read_lextintensity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_HRTS", "modulename": "surfile.measfile_io", "qualname": "read_HRTS", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.read_pointcloud", "modulename": "surfile.measfile_io", "qualname": "read_pointcloud", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.lateral_axis", "modulename": "surfile.measfile_io", "qualname": "lateral_axis", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data_lat</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.measfile_io.pointcloud_to_heightmap", "modulename": "surfile.measfile_io", "qualname": "pointcloud_to_heightmap", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dat_x</span>, </span><span class=\"param\"><span class=\"n\">dat_y</span>, </span><span class=\"param\"><span class=\"n\">dat_z</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile", "modulename": "surfile.profile", "kind": "module", "doc": "<p>'surfile.profile'</p>\n\n<ul>\n<li>data structure for profile objects</li>\n<li>plots of the profile</li>\n<li>io operation for data storage</li>\n</ul>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">surfile</span> <span class=\"kn\">import</span> <span class=\"n\">profile</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">prf</span> <span class=\"o\">=</span> <span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span><span class=\"p\">()</span> <span class=\"c1\"># instantiate an empty profile</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">prf</span><span class=\"o\">.</span><span class=\"n\">openPrf</span><span class=\"p\">(</span><span class=\"s1\">&#39;path to file&#39;</span><span class=\"p\">,</span> <span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">prf</span><span class=\"o\">.</span><span class=\"n\">pltPrf</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.profile.Profile", "modulename": "surfile.profile", "qualname": "Profile", "kind": "class", "doc": "<p>Class for handling profile data\nProvides io file operations in different formats\nProvides simple visualization plots</p>\n"}, {"fullname": "surfile.profile.Profile.__init__", "modulename": "surfile.profile", "qualname": "Profile.__init__", "kind": "function", "doc": "<p>Instantiate an empty Profile object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "surfile.profile.Profile.X", "modulename": "surfile.profile", "qualname": "Profile.X", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.profile.Profile.Z", "modulename": "surfile.profile", "qualname": "Profile.Z", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.profile.Profile.name", "modulename": "surfile.profile", "qualname": "Profile.name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.profile.Profile.openPrf", "modulename": "surfile.profile", "qualname": "Profile.openPrf", "kind": "function", "doc": "<p>Opens a .prf file from taylor hobson profilometers</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : str\n    The file path\nbplt : bool\n    If true plots the opened profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">bplt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.openCHR", "modulename": "surfile.profile", "qualname": "Profile.openCHR", "kind": "function", "doc": "<p>Opens a CHR folder containing the profile data and the\nstitching positions.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>dirname : str\n    The directory path\nbplt : bool\n    If true plots the opened profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">dirname</span>, </span><span class=\"param\"><span class=\"n\">bplt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.openTS", "modulename": "surfile.profile", "qualname": "Profile.openTS", "kind": "function", "doc": "<p>OBSOLETE: opens the talyStep data files with multiple measurements\nads asks the user which measurement to consider.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : str\n    The file path\nbplt : bool\n    If true plots the opened profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">bplt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.openTxt", "modulename": "surfile.profile", "qualname": "Profile.openTxt", "kind": "function", "doc": "<p>Opens a txt file with 2 columns [x, z]</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : str\n    The file path\nbplt : bool\n    If true plots the opened profile\nheader : int, optional\n    Number of lines to be discarded when opening the file, by default 0</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function uses np.genfromtxt() with converter</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">converters</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">:</span> <span class=\"k\">lambda</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"ow\">or</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span><span class=\"p\">)}</span>\n<span class=\"go\">this is used to correctly decect all NaN formats in txt</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">bplt</span>, </span><span class=\"param\"><span class=\"n\">header</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.saveTxt", "modulename": "surfile.profile", "qualname": "Profile.saveTxt", "kind": "function", "doc": "<p>Saves the profile in a txt format 2 columns [x, z]</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : str\n    The output file path</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.setValues", "modulename": "surfile.profile", "qualname": "Profile.setValues", "kind": "function", "doc": "<p>Sets the values for the profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>X: []\n    The X values of the profile\nY: []\n    The Y values of the profile\nbplt: bool\n    Plots the profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span>, </span><span class=\"param\"><span class=\"n\">bplt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.fillNM", "modulename": "surfile.profile", "qualname": "Profile.fillNM", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.pltPrf", "modulename": "surfile.profile", "qualname": "Profile.pltPrf", "kind": "function", "doc": "<p>Plots the profile</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.profile.Profile.pltCompare", "modulename": "surfile.profile", "qualname": "Profile.pltCompare", "kind": "function", "doc": "<p>Plots the current profile and the original data</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.stitcher", "modulename": "surfile.stitcher", "kind": "module", "doc": "<p>'surfile.stitcher'</p>\n\n<ul>\n<li>implementation of surface stitching methods</li>\n</ul>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.stitcher.SurfaceStitcher", "modulename": "surfile.stitcher", "qualname": "SurfaceStitcher", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.stitcher.SurfaceStitcher.stitchMinimizeNorm", "modulename": "surfile.stitcher", "qualname": "SurfaceStitcher.stitchMinimizeNorm", "kind": "function", "doc": "<p>Given 2 surfaces finds the best allignement\nby minimizing the norm2 of the difference</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>surl : surface.Surface\n    The left image to be stitched\nsurr : surface.Surface\n    The right image to be stitched\nstitchPrc : int\n    the percentage of the image overlapping\npixelScan: int\n    the number of pixel the method tryes to displace the images\n    an higher number results in longer excution time\nbplt : bool\n    If true plots the stitching process, limits the radius scan to 5 pixels\n    Use this only to see graphically and very slowly what this function does.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>surface.Surface\n    The stitched image</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">surl</span>, </span><span class=\"param\"><span class=\"n\">surr</span>, </span><span class=\"param\"><span class=\"n\">stitchPrc</span><span class=\"o\">=</span><span class=\"mi\">20</span>, </span><span class=\"param\"><span class=\"n\">pixelScan</span><span class=\"o\">=</span><span class=\"mi\">40</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.stitcher.SurfaceStitcher.stitchCorrelation", "modulename": "surfile.stitcher", "qualname": "SurfaceStitcher.stitchCorrelation", "kind": "function", "doc": "<p>Finds the best allignment between surl and surr\nby calculating the maximum of the cross correlation</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>samplingPrc : int\n    The percentage of the points of the overimposed\n    surfaces that is sampled from the arrays\nsurl : surface.Surface\n    The left image to be stitched\nsurr : surface.Surface\n    The right image to be stitched\nstitchPrc : int\n    the percentage of the image overlapping\ncorrelateDer : bool\n    If true uses the first derivatice for the cross correlation to\n    in order to compare the slope of the sample instead of the height\nbplt : bool\n    If true plots the stitched image</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">surl</span>,</span><span class=\"param\">\t<span class=\"n\">surr</span>,</span><span class=\"param\">\t<span class=\"n\">stitchPrc</span><span class=\"o\">=</span><span class=\"mi\">20</span>,</span><span class=\"param\">\t<span class=\"n\">samplingPrc</span><span class=\"o\">=</span><span class=\"mi\">50</span>,</span><span class=\"param\">\t<span class=\"n\">correlateDer</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.stitcher.SurfaceStitcher.stitchFGR", "modulename": "surfile.stitcher", "qualname": "SurfaceStitcher.stitchFGR", "kind": "function", "doc": "<p>Finds the best allignment between surl and surr\nby first registering approximatively the 2 images\nusing a FGR feature matcher, and then improves\nthe result by refining with an ICP (iterative closest point)\nregistration</p>\n\n<p>ref: <a href=\"http://www.open3d.org/docs/0.9.0/python_api/open3d.registration.html\">http://www.open3d.org/docs/0.9.0/python_api/open3d.registration.html</a>\nFGR: <a href=\"http://vladlen.info/papers/fast-global-registration.pdf\">http://vladlen.info/papers/fast-global-registration.pdf</a>\nICP: <a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=121791\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=121791</a>\nPFH: <a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5152473\">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5152473</a></p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>surl : surface.Surface\n    The left image to be stitched\nsurr : surface.Surface\n    The right image to be stitched\nstitchPrc : int\n    the percentage of the image overlapping</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">surl</span>, </span><span class=\"param\"><span class=\"n\">surr</span>, </span><span class=\"param\"><span class=\"n\">stitchPrc</span><span class=\"o\">=</span><span class=\"mi\">20</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface", "modulename": "surfile.surface", "kind": "module", "doc": "<p>'surfile.surface'</p>\n\n<ul>\n<li>data structure for surface objects</li>\n<li>plots of the surface</li>\n<li>io operation</li>\n</ul>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">surfile</span> <span class=\"kn\">import</span> <span class=\"n\">surface</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sur</span> <span class=\"o\">=</span> <span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span><span class=\"p\">()</span> <span class=\"c1\"># instantiate an empty surface</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sur</span><span class=\"o\">.</span><span class=\"n\">openFile</span><span class=\"p\">(</span><span class=\"s1\">&#39;path to file&#39;</span><span class=\"p\">,</span> <span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sur</span><span class=\"o\">.</span><span class=\"n\">pltC</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>@author: Andrea Giura</p>\n"}, {"fullname": "surfile.surface.Surface", "modulename": "surfile.surface", "qualname": "Surface", "kind": "class", "doc": "<p>Class for handling surface data\nProvides io file operations in different formats\nProvides simple visualization plots</p>\n"}, {"fullname": "surfile.surface.Surface.__init__", "modulename": "surfile.surface", "qualname": "Surface.__init__", "kind": "function", "doc": "<p>Instantiate an empty Surface object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "surfile.surface.Surface.Z", "modulename": "surfile.surface", "qualname": "Surface.Z", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.surface.Surface.Y", "modulename": "surfile.surface", "qualname": "Surface.Y", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.surface.Surface.X", "modulename": "surfile.surface", "qualname": "Surface.X", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.surface.Surface.y", "modulename": "surfile.surface", "qualname": "Surface.y", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.surface.Surface.x", "modulename": "surfile.surface", "qualname": "Surface.x", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.surface.Surface.rangeY", "modulename": "surfile.surface", "qualname": "Surface.rangeY", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.surface.Surface.rangeX", "modulename": "surfile.surface", "qualname": "Surface.rangeX", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.surface.Surface.name", "modulename": "surfile.surface", "qualname": "Surface.name", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.surface.Surface.openTxt", "modulename": "surfile.surface", "qualname": "Surface.openTxt", "kind": "function", "doc": "<p>Opens a txt file containing the values of the topography\nsee Notes for more information on file format.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : str\n    The file path\nbplt : bool\n    If true plots the opened surface\ntyp : str, optional\n    Type of text file see Notes, by default 'x'</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This method accepts two different txt formats:</p>\n\n<ul>\n<li>typ = 's' txt file with 4 header lines with values respectively \n[nx, ny, dx, dy] and then the list of Z values of the array.</li>\n<li>typ = 'x' txt file with three columns [x, y, z]</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span>, </span><span class=\"param\"><span class=\"n\">bplt</span>, </span><span class=\"param\"><span class=\"n\">typ</span><span class=\"o\">=</span><span class=\"s1\">&#39;x&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.openFile", "modulename": "surfile.surface", "qualname": "Surface.openFile", "kind": "function", "doc": "<p>Opens a file from a supported intrument, the list of \nsupported types is in measfile_io documentation.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : str\n    The file path\nbplt : bool\n    If true plots the opened surface\ninterp : bool, optional\n    If true uses interpolation to fill NaNs, by default False\nuserscalecorrections : list\n    Array to correct the values of the topography [x_mul, y_mul, z_mul].</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">fname</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span>,</span><span class=\"param\">\t<span class=\"n\">interp</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">userscalecorrections</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.saveAsc", "modulename": "surfile.surface", "qualname": "Surface.saveAsc", "kind": "function", "doc": "<p>Saves the topography in the .asc file format of the tracOptic project</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : str\n    If fname is a folder the file will be saved in that folder with the surface name\n    If fname is not a folder the file will be saved at fname</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The tracOptic file format: </p>\n\n<p>{self.name}</p>\n\n<p>X - length: {max(self.x) - min(self.x)}</p>\n\n<p>Y - length: {max(self.y) - min(self.y)}</p>\n\n<p>X - pixel number: {len(self.x)}</p>\n\n<p>Y - pixel number: {len(self.y)}</p>\n\n<p>Z - data array start: (all the values of the Z array)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.saveTxt", "modulename": "surfile.surface", "qualname": "Surface.saveTxt", "kind": "function", "doc": "<p>Saves the topography in the .txt file format with three cols</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fname : str\n    If fname is a folder the file will be saved in that folder with the surface name\n    If fname is not a folder the file will be saved at fname</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.rotate", "modulename": "surfile.surface", "qualname": "Surface.rotate", "kind": "function", "doc": "<p>Rotates the original topography by the specified angle</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>angle: float\n    The angle of rotation</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p><span style=\"color:orange\">This function will be moved to a utility module in the future\nuse with caution !!!</span>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">angle</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.resample", "modulename": "surfile.surface", "qualname": "Surface.resample", "kind": "function", "doc": "<p>Resamples the topography and fills the non-measured points</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>newXsize: int\n    Number of points desired on the x-axis\nnewYsize: int\n    Number of points desired on the y-axis</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p><span style=\"color:orange\">This function will be moved to a utility module in the future\nuse with caution !!!</span>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newXsize</span>, </span><span class=\"param\"><span class=\"n\">newYsize</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.fillNM", "modulename": "surfile.surface", "qualname": "Surface.fillNM", "kind": "function", "doc": "<p>Fills the surface non measured points</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>method : str\n    The interpolation method used</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p><span style=\"color:orange\">This function will be moved to a utility module in the future\nuse with caution !!!</span>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;cubic&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.chauvenet", "modulename": "surfile.surface", "qualname": "Surface.chauvenet", "kind": "function", "doc": "<p>Removes the outliers from the topography\nusing the chouvenet criterion</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>iterative : bool\n    If true keeps calling the function until the number of outliers is 0\n    If true the mean and stdv parameters are ignored as if they were not provided\nthreshold : float\n    The acceptance threshold of the criterion\nmean : float\n    The mean of the expected distribution\n    If none the program calculates the mean of the distribution\nstdv : float\n    The std dev of the expected distribution\n    If none the program calculates the std dev of the distribution</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p><span style=\"color:orange\">This function will be moved to a utility module in the future\nuse with caution !!!</span>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">iterative</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.5</span>, </span><span class=\"param\"><span class=\"n\">mean</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">stdv</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.toProfiles", "modulename": "surfile.surface", "qualname": "Surface.toProfiles", "kind": "function", "doc": "<p>Splits the topography into vertical or horizontal profiles</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>axis: str\n    'x' or 'y', the axis on which the f is applied</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>res: []\n    The resulting profiles</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"s1\">&#39;x&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.plt3D", "modulename": "surfile.surface", "qualname": "Surface.plt3D", "kind": "function", "doc": "<p>Plots a 3D view of the surface</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.pltCompare", "modulename": "surfile.surface", "qualname": "Surface.pltCompare", "kind": "function", "doc": "<p>Plots the current topography data and the original data</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.surface.Surface.pltC", "modulename": "surfile.surface", "qualname": "Surface.pltC", "kind": "function", "doc": "<p>Plots the topography (pcolormesh)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.texture", "modulename": "surfile.texture", "kind": "module", "doc": "<p>'surfile.roughness'</p>\n\n<ul>\n<li>analysis of roughness features for:\n<ul>\n<li>Profiles</li>\n<li>Surfaces</li>\n</ul></li>\n</ul>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">psd</span> <span class=\"o\">=</span> <span class=\"n\">texture</span><span class=\"o\">.</span><span class=\"n\">Psd</span><span class=\"p\">()</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">psd</span><span class=\"o\">.</span><span class=\"n\">evalPsd</span><span class=\"p\">(</span><span class=\"n\">sur</span><span class=\"p\">,</span> <span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">avg</span> <span class=\"o\">=</span> <span class=\"n\">psd</span><span class=\"o\">.</span><span class=\"n\">averageSpectra</span><span class=\"p\">(</span><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">psd</span><span class=\"o\">.</span><span class=\"n\">angleIntegratedSpectra</span><span class=\"p\">(</span><span class=\"n\">dt_fct</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">psd</span><span class=\"o\">.</span><span class=\"n\">polarSpectra</span><span class=\"p\">(</span><span class=\"n\">df_fct</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>@author: Dorothee Hueser, Andrea Giura</p>\n"}, {"fullname": "surfile.texture.Psd", "modulename": "surfile.texture", "qualname": "Psd", "kind": "class", "doc": "<p>Class that provides the data structure and methods for PSD\ncalculation.</p>\n"}, {"fullname": "surfile.texture.Psd.__init__", "modulename": "surfile.texture", "qualname": "Psd.__init__", "kind": "function", "doc": "<p>Instantiate an empty psd object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "surfile.texture.Psd.deltaX", "modulename": "surfile.texture", "qualname": "Psd.deltaX", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Psd.deltaY", "modulename": "surfile.texture", "qualname": "Psd.deltaY", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Psd.psd", "modulename": "surfile.texture", "qualname": "Psd.psd", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Psd.psdp", "modulename": "surfile.texture", "qualname": "Psd.psdp", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Psd.fx", "modulename": "surfile.texture", "qualname": "Psd.fx", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Psd.fy", "modulename": "surfile.texture", "qualname": "Psd.fy", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Psd.psdx", "modulename": "surfile.texture", "qualname": "Psd.psdx", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Psd.psdy", "modulename": "surfile.texture", "qualname": "Psd.psdy", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Psd.evalPsd", "modulename": "surfile.texture", "qualname": "Psd.evalPsd", "kind": "function", "doc": "<p>Evaluate the power spectral density of the topography</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The topography\nbplt: bool\n    If True plots the PSD result</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>psd: np.ndarray\n    The calculated psd of the surface\nfx, fy: np.array\n    The x and y axis of the psd\npsd_x, psd_y: np.ndarray\n    The psd along the given axis</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The power spectral density (PSD) function gives indication on  the strength \nof different frequency components  as function of the spatial frequency and \nis calculated from the absolute value of the square of the Fourier transform \nof the height values z(x,y).\nThe areal Fourier transform is given by:</p>\n\n<p>$\n\\begin{equation}\nF_z(f_x,f_y)=\\lim_{L_x \\to \\infty}\\lim_{Ly \\to \\infty} \\frac{1}{L_x L_y}\\int_{-L_y/2}^{L_y/2}\\int_{-L_x/2}^{L_x/2}z(x,y)e^{[-i2\\pi(f_xx+f_yy)]}dxdy\n\\end{equation}\n$</p>\n\n<p>The Power Spectral Density is then calculated as:</p>\n\n<p>$\n\\begin{equation}\n    P(f_x,f_y)=\\frac{d}{df_x}\\frac{d}{df_y}F_z^*(f_x,f_y)F_z(f_x,f_y)\n\\end{equation}\n$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">surface</span><span class=\"o\">.</span><span class=\"n\">Surface</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.texture.Psd.polarSpectra", "modulename": "surfile.texture", "qualname": "Psd.polarSpectra", "kind": "function", "doc": "<p>Calculate the spectra in polar coordinates</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_fct: float\n    The frequency resolution\nbplt: bool\n    If true the spectra is plotted in a 3d projection axis</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>psdP: np.ndarray\n    The polar spectra evaluated\nFr, Th: np.array\n    The polar coordinate vectors</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df_fct</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.texture.Psd.angleIntegratedSpectra", "modulename": "surfile.texture", "qualname": "Psd.angleIntegratedSpectra", "kind": "function", "doc": "<p>Calculate the angle integrated spectra</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>df_fct: float\nbplt: bool\n    If true the angle integrated spectra is plotted</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>psdP: np.ndarray\n    The polar spectra evaluated\nFr, Th: np.array\n    The polar coordinate vectors</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">df_fct</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.texture.Psd.averageSpectra", "modulename": "surfile.texture", "qualname": "Psd.averageSpectra", "kind": "function", "doc": "<p>Calculate the average specra in the x and y directions</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>bplt: bool\n    Plots the mean spectra if true</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>psdMeanx, psdMeany: np.array\n    The mean psd arrays</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.texture.Roi", "modulename": "surfile.texture", "qualname": "Roi", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Roi.__init__", "modulename": "surfile.texture", "qualname": "Roi.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>, </span><span class=\"param\"><span class=\"n\">Z</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "surfile.texture.Roi.X", "modulename": "surfile.texture", "qualname": "Roi.X", "kind": "variable", "doc": "<p></p>\n", "annotation": ": &lt;built-in function array&gt;"}, {"fullname": "surfile.texture.Roi.Z", "modulename": "surfile.texture", "qualname": "Roi.Z", "kind": "variable", "doc": "<p></p>\n", "annotation": ": &lt;built-in function array&gt;"}, {"fullname": "surfile.texture.Parameters", "modulename": "surfile.texture", "qualname": "Parameters", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "surfile.texture.Parameters.calc", "modulename": "surfile.texture", "qualname": "Parameters.calc", "kind": "function", "doc": "<p>Calculates the roughness parameters of a profile</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: profile.Profile\n    The profile on which the parameters are calculates\nrem: remover.Remover\n    - if None, the low frequency components are not filtered\nfil: filter.Filter\n    The filter that is applied before the calculations. The cutoff\n    of the filter is used to select the central region of the profile,\n    half cutof is not condsidered at the adges of the rofile\nbplt: bool\n    If true plots the profile after the pre-proocessing</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>RA, RQ, RP, RV, RZ, RSK, RKU: (float, ...)\n    Calculated roughness parameters</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obj</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">profile</span><span class=\"o\">.</span><span class=\"n\">Profile</span>,</span><span class=\"param\">\t<span class=\"n\">rem</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">geometry</span><span class=\"o\">.</span><span class=\"n\">FormEstimator</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fil</span><span class=\"p\">:</span> <span class=\"n\">surfile</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"o\">.</span><span class=\"n\">Filter</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bplt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "surfile.texture.slopeDistribution", "modulename": "surfile.texture", "qualname": "slopeDistribution", "kind": "function", "doc": "<p>Calculates the slope distribution in angles theta and phi</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obj: surface.Surface\n    The surface n wich the slope distribution is calculated\nstructured: bool\n    If true the method assumes equal spacing along x-axis (dx) and equal spacing along\n    y-axis\n    If false the method uses a generalized triangle approach (recommended)\ntheta_res: float\n    The angle resolution for the theta angle\nphi_res: float\n    The angle resolution for the phi angle\nadaptive_hist: bool\n    If true the bins are calculated between 0 and the max angles\n    If false the bins are calculated between 0 - 90 for theta, 0 - 360 for phi\nbplt: bool\n    If True plots the calculated histograms</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>(hist_theta, edges_theta): tuple\n    The theta histogram\n(hist_phi, edges_phi): tuple\n    The phi histogram</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This method performs a slope distribution analysis on the surface by calculating all \nthe normal vectors to the triangles constructed on the adjacent points of the topography. \nThe normal vectors are then expressed in polar coordinates and for the two angles \n(elevation, azimuth) a histogram plot is generated. The number of bins for each angle can \nbe specified by the user by setting the two parameters res and adaptive_hist.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();